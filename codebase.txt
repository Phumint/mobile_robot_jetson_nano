.
â”œâ”€â”€ codebase.txt
â”œâ”€â”€ create_codebase.sh
â”œâ”€â”€ .git
â”‚Â Â  â”œâ”€â”€ branches
â”‚Â Â  â”œâ”€â”€ config
â”‚Â Â  â”œâ”€â”€ description
â”‚Â Â  â”œâ”€â”€ HEAD
â”‚Â Â  â”œâ”€â”€ hooks
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ applypatch-msg.sample
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ commit-msg.sample
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ fsmonitor-watchman.sample
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ post-update.sample
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ pre-applypatch.sample
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ pre-commit.sample
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ prepare-commit-msg.sample
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ pre-push.sample
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ pre-rebase.sample
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ pre-receive.sample
â”‚Â Â  â”‚Â Â  â””â”€â”€ update.sample
â”‚Â Â  â”œâ”€â”€ index
â”‚Â Â  â”œâ”€â”€ info
â”‚Â Â  â”‚Â Â  â””â”€â”€ exclude
â”‚Â Â  â”œâ”€â”€ logs
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ HEAD
â”‚Â Â  â”‚Â Â  â””â”€â”€ refs
â”‚Â Â  â”‚Â Â      â”œâ”€â”€ heads
â”‚Â Â  â”‚Â Â      â”‚Â Â  â””â”€â”€ main
â”‚Â Â  â”‚Â Â      â””â”€â”€ remotes
â”‚Â Â  â”‚Â Â          â””â”€â”€ origin
â”‚Â Â  â”‚Â Â              â””â”€â”€ HEAD
â”‚Â Â  â”œâ”€â”€ objects
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 05
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 93516dfd300216bc37ef160c0898fe744d6ce7
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 0a
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 28d630906fca8da875aea77af34d9cbf42640b
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 296f14b3d8f2cfcd8d0be0dd4b77c3d0fa4145
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 0d
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 1c7383382fc64a9fc729a161e7f1612fb60e71
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 0e
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 1fe2075a854c87f029b506a3fd7a8fcfb50dbc
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 14
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 253db5d5378988b2b60257172c0f221b58d58c
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 17
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 7f42ab3b94e7a53c3e721d719a4e1ea897789e
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 19
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ db1622f6b901b2f7c166e3795822d6522d5c27
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 1e
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 1df454d52249826b4eef68d24409304cb55f15
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 1f
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ fdfe703ed41637c1b09cbecd7d41dc898c3835
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 25
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ f0d316b87c2bd8511e7b0e44f6e75c69dc66da
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 26
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 2e86c8e0c168f25a1bdd678257e820e8b98285
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 27
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ccd8f5e7a92b9183ec9ec3215f21afd9744496
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ ee1078ff077cc3a0fec75b7d023101a68164d1
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 28
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 1338e48da3cdbca17efd5ca385e3f5e087c6dc
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 29
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ ea02eb44a1169299936b36944e22d4d18c58dc
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 2d
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 8001a0c3e704b6e17103993c565e9a51749e5a
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 2f
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ d184a231084d36e27ccb7fcdd9302368cabcc0
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 32
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 4a80c10474c81d1672bc59a68b0c8163fc75db
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 4e
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 2e6a4fb47dde9e23f4939f67022d551af2cf58
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ dbce0a341de448dfdb01b728102d6f830a7ebe
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 5a
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 1b1bdc72766fda41dff8141db633b600426300
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 5d
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 3a809484ed37f8ce5bf1532b8aa3ae255590ab
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 62
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 9eea032be0638e04bad9de5a56d463c95265b3
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 63
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 54f2fdb971b6a6c9dda0b0e961efee9f6daaac
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 64
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 51371ea5c508fd554618f3a26598821267d917
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 65
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 85f9d98f954e9c0beb3880fcde25ed37e2c729
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 66
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ fb1949f25e52fa6b0ee59fb8a5fdd31f402343
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 67
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ c46885e80b68c07b396ad0685ff745c73743c3
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 69
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 9928e2ec513ccf11c2937014f424488f135f7f
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 6b
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 0d148ca8e221d8e7bb8328cb1b62b823cc6ae5
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 6f
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ c928825a70d274e13da6e04cdc5d2a9e8ec0cc
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 71
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 22e489e3cf80c0a2c859b58daea26632388bb9
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 73
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 7fcab0d498236648f8fac04381f3d87b0cc622
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 75
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 260eaad7b1b5f7745954f043207ae0421662ea
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 77
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ e0b0551fd3535efc94f5eba50699782910ef1b
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 78
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 53735af580fae97fd4b55d3f5e9b6aa1dda353
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 6ca239ef6f5533c4f7ab6374d8402c1d724533
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 7d
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 11704c363db43f3b7a8ec41b16b4f1fc56b8eb
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 7e
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 273bd7f91e22f45185095841a3991fde99555d
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 85
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 7bfe84873199b5e5bc4298961c3e0d954270c5
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 86
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ d9faaba8bde2700ffd55e34fc0efcd78661a5c
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 87
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 3711199b5a7553691878c1e50c46b3cab41a7d
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 8b
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ ee9f9d300c55a8a3c5aa8bb18a78e167ba10d7
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 8c
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 5035a6af9a7e2786cb469fb38ee95ea70f66c2
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 8f
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 8195387c4904fabb126a4083be4071fdea52fc
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 90
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 2c5dde7b954a26dfc1e9777e59b47b22f7ab5b
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 91
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 96a00abb961cadb84694471a0f7544e88b9955
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 92
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ dddee4029292644283e0b03c92fd1451494e35
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 96
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 2ef7913f0f5c72735e52ce91870aee4b0cf8c4
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ b8ab2f37626358c4c877be3f2bd6cf904cfa62
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 97
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ a062b74fa007349f97f333a18ef8cfef03883d
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ a39196e84db97954341162a6d2e7f771d938c0
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ cad041615d006744e8064e3a9ac3f9bcda07dc
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 99
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 367b3dd9fe87ac0a1e2fd9c78d0b0f348de18e
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ f13cc9a1801f2be598d3f127515bb4411018c6
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ a3
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 3ba79801135a1b80760603278883030aad2582
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ b00b0b02b23663fc8c4352e40dfd3a324d1d01
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ a7
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 1b5c2e08d7df552608c5da4d9a519d10a54268
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ a9
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 7428b8d8f9e0e5c7279bc6405c3accf30002ad
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ab
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 97494858835b42812bc20568da26c2d6cf5b5d
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ac
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 74d1e6bd19665f5f3e21a59f35b25df4a4ccad
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ a4541a698c2c127851e955efb7953b4f30aa3b
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ b2
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 34a3840f4c5bd38f043638c8622b8f240e1185
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ b4
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 8769ba8602a0dd38794b29bebf26c2b43fc0b7
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ b7
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ e43c0e2aa6a5f7e8081a1fb392a42372c88567
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ be
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ d9b4cfcd920abcc7a5478433dceb613ecbc57e
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ c3
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 4cc62e60a73e0363cc4fbb40e3d62d8af6d97f
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 7cdb3dfdf3edc255f237fa129e42f9eecdc885
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ c7
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ b484412475e973b2cfb7a124f45beb8117f04f
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ cd
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ af34fd9f6e32e4f42553aeba9ef8cd026b2f0c
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ d3
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 31f1e905dd7a8196e6463eea1714c715434225
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ dc
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 0cc9962e808dc31de91fe2b3b1d1a57dea448c
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ de
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 6efb7b8388e051911bbf60597d26f41857bcb1
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ e0
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 44a6f0bf3446b62dcafcca855b9bdd58db6d22
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ e1
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 0029ef74a689b3d57c1e143db99d6bd7a2e519
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 60d83e4484a90870d9dff75b99ea3d59d4c733
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ d424048a11cfa453715055386d5bd0cfb75efd
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ e6
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 9de29bb2d1d6434b8b29ae775ad8c2e48c5391
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ e9
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ c045470736d7ce5d06270060f665cb172209d9
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ ee
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 107a79f1d6563c84f1936aeed156f4bcaf9706
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ f0
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 94633808d51fa5f2ad823a5294ea2c7fff0779
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ f2
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ a04a69b98f82e0db168fd2df57302e92abb2ff
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ f4
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 225db7828742b5e7d12aedb8658df60af399bf
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ f5
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 2ba7be902ad82d9b0432eceb4e6338e15e33c0
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ f9
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 57c1c9d85b54b93137524780ab3d3bc3364819
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ fa
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ e6baf6ab8cf9b62de8285eeea7192addc4dfa0
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ fb
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 7ff4179e651276b8fd84e2d453fa2b3d25a287
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ info
â”‚Â Â  â”‚Â Â  â””â”€â”€ pack
â”‚Â Â  â”œâ”€â”€ packed-refs
â”‚Â Â  â””â”€â”€ refs
â”‚Â Â      â”œâ”€â”€ heads
â”‚Â Â      â”‚Â Â  â””â”€â”€ main
â”‚Â Â      â”œâ”€â”€ remotes
â”‚Â Â      â”‚Â Â  â””â”€â”€ origin
â”‚Â Â      â”‚Â Â      â””â”€â”€ HEAD
â”‚Â Â      â””â”€â”€ tags
â”œâ”€â”€ .gitignore
â””â”€â”€ src
    â”œâ”€â”€ car_bringup
    â”‚Â Â  â”œâ”€â”€ CMakeLists.txt
    â”‚Â Â  â”œâ”€â”€ config
    â”‚Â Â  â”œâ”€â”€ launch
    â”‚Â Â  â”‚Â Â  â”œâ”€â”€ sensors.launch.py
    â”‚Â Â  â”‚Â Â  â””â”€â”€ teleop.launch.py
    â”‚Â Â  â””â”€â”€ package.xml
    â””â”€â”€ car_hardware
        â”œâ”€â”€ car_hardware
        â”‚Â Â  â”œâ”€â”€ game_control_cli.py
        â”‚Â Â  â”œâ”€â”€ __init__.py
        â”‚Â Â  â”œâ”€â”€ __pycache__
        â”‚Â Â  â”œâ”€â”€ servo_calibration_node.py
        â”‚Â Â  â”œâ”€â”€ stm32_driver_node.py
        â”‚Â Â  â””â”€â”€ teleop_keyboard_node.py
        â”œâ”€â”€ package.xml
        â”œâ”€â”€ resource
        â”‚Â Â  â””â”€â”€ car_hardware
        â”œâ”€â”€ setup.cfg
        â”œâ”€â”€ setup.py
        â””â”€â”€ test
            â”œâ”€â”€ test_copyright.py
            â”œâ”€â”€ test_flake8.py
            â””â”€â”€ test_pep257.py

101 directories, 129 files

==========================================

--- File: ./src/car_bringup/launch/sensors.launch.py ---
#!/usr/bin/env python3

from launch import LaunchDescription
from launch_ros.actions import Node
from launch.actions import DeclareLaunchArgument
from launch.substitutions import LaunchConfiguration

def generate_launch_description():
    
    serial_port_arg = DeclareLaunchArgument(
        'serial_port',
        default_value='/dev/ttyTHS1',
        description='Serial port for STM32'
    )
    
    # STM32 Driver Node (sensors only mode)
    stm32_driver = Node(
        package='car_hardware',
        executable='stm32_driver',
        name='stm32_driver_node',
        output='screen',
        parameters=[{
            'serial_port': LaunchConfiguration('serial_port'),
            'baud_rate': 115200
        }]
    )
    
    return LaunchDescription([
        serial_port_arg,
        stm32_driver,
    ])

--- File: ./src/car_bringup/launch/teleop.launch.py ---
#!/usr/bin/env python3

from launch import LaunchDescription
from launch_ros.actions import Node
from launch.actions import DeclareLaunchArgument
from launch.substitutions import LaunchConfiguration

def generate_launch_description():
    
    # Declare arguments
    serial_port_arg = DeclareLaunchArgument(
        'serial_port',
        default_value='/dev/ttyTHS1',
        description='Serial port for STM32'
    )
    
    # STM32 Driver Node
    stm32_driver = Node(
        package='car_hardware',
        executable='stm32_driver',
        name='stm32_driver_node',
        output='screen',
        parameters=[{
            'serial_port': LaunchConfiguration('serial_port'),
            'baud_rate': 115200,
            'wheel_base': 0.25,
            'max_speed': 1.0,
            'max_steering_angle': 40.0
        }]
    )
    
    # Teleop Keyboard Node
    teleop_keyboard = Node(
        package='car_hardware',
        executable='teleop_keyboard',
        name='teleop_keyboard_node',
        output='screen',
        parameters=[{
            'speed_step': 0.1,
            'turn_step': 0.3,
            'max_speed': 1.0,
            'max_turn': 1.0
        }],
        prefix='xterm -e'  # Run in separate terminal
    )
    
    return LaunchDescription([
        serial_port_arg,
        stm32_driver,
        # teleop_keyboard,  # Uncomment to auto-launch teleop
    ])

--- File: ./src/car_bringup/package.xml ---
<?xml version="1.0"?>
<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
<package format="3">
  <name>car_bringup</name>
  <version>0.0.0</version>
  <description>TODO: Package description</description>
  <maintainer email="root@todo.todo">root</maintainer>
  <license>TODO: License declaration</license>

  <buildtool_depend>ament_cmake</buildtool_depend>

  <test_depend>ament_lint_auto</test_depend>
  <test_depend>ament_lint_common</test_depend>

  <export>
    <build_type>ament_cmake</build_type>
  </export>
</package>

--- File: ./src/car_bringup/CMakeLists.txt ---
cmake_minimum_required(VERSION 3.8)
project(car_bringup)

if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
  add_compile_options(-Wall -Wextra -Wpedantic)
endif()

# find dependencies
find_package(ament_cmake REQUIRED)

# Install launch files
install(DIRECTORY
  launch
  config
  DESTINATION share/${PROJECT_NAME}/
)

if(BUILD_TESTING)
  find_package(ament_lint_auto REQUIRED)
  ament_lint_auto_find_test_dependencies()
endif()

ament_package()

--- File: ./src/car_hardware/resource/car_hardware ---

--- File: ./src/car_hardware/package.xml ---
<?xml version="1.0"?>
<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
<package format="3">
  <name>car_hardware</name>
  <version>0.0.0</version>
  <description>TODO: Package description</description>
  <maintainer email="root@todo.todo">root</maintainer>
  <license>TODO: License declaration</license>

  <depend>rclpy</depend>
  <depend>geometry_msgs</depend>
  <depend>sensor_msgs</depend>
  <depend>std_msgs</depend>
  <depend>nav_msgs</depend>

  <test_depend>ament_copyright</test_depend>
  <test_depend>ament_flake8</test_depend>
  <test_depend>ament_pep257</test_depend>
  <test_depend>python3-pytest</test_depend>

  <export>
    <build_type>ament_python</build_type>
  </export>
</package>

--- File: ./src/car_hardware/setup.py ---
from setuptools import setup
import os
from glob import glob

package_name = 'car_hardware'

setup(
    name=package_name,
    version='0.0.1',
    packages=[package_name],
    data_files=[
        ('share/ament_index/resource_index/packages',
            ['resource/' + package_name]),
        ('share/' + package_name, ['package.xml']),
    ],
    install_requires=['setuptools'],
    zip_safe=True,
    maintainer='your_name',
    maintainer_email='your_email@example.com',
    description='Hardware interface for RC car',
    license='MIT',
    tests_require=['pytest'],
    entry_points={
        'console_scripts': [
            'stm32_driver = car_hardware.stm32_driver_node:main',
            'teleop_keyboard = car_hardware.teleop_keyboard_node:main',
            'game_control_cli = car_hardware.game_control_cli:main',
            'servo_calibration_node = car_hardware.servo_calibration_node:main',

        ],
    },
)

--- File: ./src/car_hardware/setup.cfg ---
[develop]
script_dir=$base/lib/car_hardware
[install]
install_scripts=$base/lib/car_hardware

--- File: ./src/car_hardware/car_hardware/stm32_driver_node.py ---
#!/usr/bin/env python3
"""
STM32 Driver Node (Optimized)
Improvements: 
1. Dynamic dt calculation for accurate Yaw integration.
2. Allows steering wheels to turn even when stopped.
3. Thread-safe serial writes.
4. Robust shutdown procedure.
"""

import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist
from sensor_msgs.msg import Imu
from std_msgs.msg import Int32
import serial
import threading
import math
import time

class STM32DriverNode(Node):
    def __init__(self):
        super().__init__('stm32_driver_node')

        # --- Parameters ---
        self.declare_parameter('serial_port', '/dev/ttyTHS1')
        self.declare_parameter('baud_rate', 115200)
        self.declare_parameter('wheel_base', 0.135)
        self.declare_parameter('max_speed_m_s', 0.5) # Renamed for clarity
        self.declare_parameter('max_steering_angle_deg', 25.0)

        self.port = self.get_parameter('serial_port').value
        self.baud = self.get_parameter('baud_rate').value
        self.wheel_base = self.get_parameter('wheel_base').value
        self.max_speed = self.get_parameter('max_speed_m_s').value
        self.max_steer = self.get_parameter('max_steering_angle_deg').value

        # --- Serial Connection ---
        self.serial = None
        self.serial_lock = threading.Lock() # Prevent read/write collisions
        self._open_serial()

        # --- ROS2 Interfaces ---
        self.encoder_pub = self.create_publisher(Int32, 'encoder_count', 10)
        self.imu_pub = self.create_publisher(Imu, 'imu/data_raw', 10)
        
        self.cmd_vel_sub = self.create_subscription(
            Twist, 'cmd_vel', self.cmd_vel_callback, 10
        )

        # --- State Variables ---
        self.last_imu_time = self.get_clock().now()
        self.integrated_yaw = 0.0
        
        # --- Threading ---
        self.running = True
        self.read_thread = threading.Thread(target=self.serial_read_loop, daemon=True)
        self.read_thread.start()

        self.get_logger().info("STM32 Driver Node initialized.")

    def _open_serial(self):
        try:
            if self.serial and self.serial.is_open:
                self.serial.close()
            self.serial = serial.Serial(self.port, self.baud, timeout=0.1)
            self.get_logger().info(f"Connected to STM32 on {self.port}")
        except Exception as e:
            self.get_logger().error(f"Failed to open serial port: {e}")
            self.serial = None

    # ---------------------------
    #  CMD_VEL CALLBACK (Control)
    # ---------------------------
    def cmd_vel_callback(self, msg):
        linear = msg.linear.x
        angular = msg.angular.z

        # --- CALIBRATION VALUES ---
        STEERING_RATIO = 2.07
        SERVO_OFFSET   = 0
        SERVO_MIN      = 20
        SERVO_MAX      = 137
        # --------------------------

        # 1. Calculate Steering (Ackermann)
        if abs(angular) > 0.001:
            safe_linear = linear if abs(linear) > 0.01 else 0.01
            steering_rad = math.atan((angular * self.wheel_base) / safe_linear)
            steering_deg = math.degrees(steering_rad)
        else:
            steering_deg = 0.0

        # 2. Apply Calibration to Servo
        # Calculate the PWM shift required
        pwm_shift = steering_deg * STEERING_RATIO
        
        # Apply to Center (90 + Offset)
        # NOTE: If Positive angular (Left) makes the servo number GO DOWN (e.g. 90 -> 50), use MINUS.
        # If Positive angular makes servo number GO UP, change this to PLUS.
        servo_cmd = (90 + SERVO_OFFSET) - int(pwm_shift) 
        
        # 3. Safety Clamp (The most important part!)
        # This prevents the servo from buzzing/burning out
        servo_cmd = max(SERVO_MIN, min(SERVO_MAX, servo_cmd))

        # 4. Calculate Motor Speed
        speed_cmd = int((linear / self.max_speed) * 100)
        speed_cmd = max(-100, min(100, speed_cmd))

        self.send_packet(speed_cmd, servo_cmd)

    def send_packet(self, speed, angle):
        if not self.serial:
            return
        
        packet = f"#CMD,{speed},{angle}*\n" # Added \n for robustness
        try:
            with self.serial_lock:
                self.serial.write(packet.encode())
        except Exception as e:
            self.get_logger().warn(f"Serial write failed: {e}")
            self._open_serial()

    # ---------------------------
    #  SERIAL READ LOOP
    # ---------------------------
    def serial_read_loop(self):
        while self.running and rclpy.ok():
            if not self.serial:
                time.sleep(1)
                self._open_serial()
                continue

            try:
                # readline blocks for timeout (0.1s)
                line = self.serial.readline().decode('utf-8', errors='ignore').strip()
                
                if not line:
                    continue # Timeout or empty

                # Validate Packet Format
                if line.startswith('$') and line.endswith('*'):
                    self.parse_sensor_data(line)
            
            except serial.SerialException:
                self.get_logger().error("Serial connection lost.")
                self.serial.close()
                self.serial = None
            except Exception as e:
                self.get_logger().warn(f"Read error: {e}")

    # ---------------------------
    #  PARSING & PUBLISHING
    # ---------------------------
    def parse_sensor_data(self, line):
        # Format: $ENC,12345;IMU,ax,ay,az,gx,gy,gz,roll,pitch*
        try:
            content = line[1:-1] # Strip $ and *
            parts = content.split(';')
            
            for part in parts:
                if part.startswith("ENC"):
                    self.handle_encoder(part)
                elif part.startswith("IMU"):
                    self.handle_imu(part)
        except ValueError:
            pass # Malformed numbers

    def handle_encoder(self, part):
        # part = "ENC,12345"
        try:
            val = int(part.split(',')[1])
            msg = Int32()
            msg.data = val
            self.encoder_pub.publish(msg)
        except IndexError:
            pass

    def handle_imu(self, part):
        # part = "IMU,ax,ay,az,gx,gy,gz,roll,pitch" (integers scaled)
        # SCALING MUST MATCH STM32 CODE:
        # Accel / 1000.0, Gyro / 100.0, Euler / 100.0
        vals = part.split(',')[1:]
        if len(vals) < 8: return

        ax = float(vals[0]) / 1000.0
        ay = float(vals[1]) / 1000.0
        az = float(vals[2]) / 1000.0
        gx = float(vals[3]) / 100.0
        gy = float(vals[4]) / 100.0
        gz = float(vals[5]) / 100.0
        # roll/pitch ignored for orientation calculation 
        # because we calculate quaternion from gyro integration + accel usually, 
        # but here we just use what we have.

        # --- Dynamic Time Integration ---
        current_time = self.get_clock().now()
        dt = (current_time - self.last_imu_time).nanoseconds / 1e9
        self.last_imu_time = current_time

        # Avoid integration spikes if connection lagged
        if dt > 1.0: dt = 0.0 

        # Integrate Yaw (Gyro Z)
        self.integrated_yaw += math.radians(gz) * dt

        self.publish_imu_msg(ax, ay, az, gx, gy, gz)

    def publish_imu_msg(self, ax, ay, az, gx, gy, gz):
        msg = Imu()
        msg.header.stamp = self.get_clock().now().to_msg()
        msg.header.frame_id = "imu_link"

        # Linear Accel
        msg.linear_acceleration.x = ax * 9.81
        msg.linear_acceleration.y = ay * 9.81
        msg.linear_acceleration.z = az * 9.81

        # Angular Velocity
        msg.angular_velocity.x = math.radians(gx)
        msg.angular_velocity.y = math.radians(gy)
        msg.angular_velocity.z = math.radians(gz)

        # Orientation (Quaternion from Yaw only for planar robot)
        # Assuming the robot stays mostly flat, we simplify to Yaw rotation
        cy = math.cos(self.integrated_yaw * 0.5)
        sy = math.sin(self.integrated_yaw * 0.5)
        
        # Simple Yaw-only Quaternion (w, x, y, z)
        msg.orientation.w = cy
        msg.orientation.x = 0.0
        msg.orientation.y = 0.0
        msg.orientation.z = sy

        self.imu_pub.publish(msg)

    def destroy_node(self):
        self.running = False
        # Stop the robot on shutdown
        self.send_packet(0, 90) 
        if self.serial:
            self.serial.close()
        super().destroy_node()

def main(args=None):
    rclpy.init(args=args)
    node = STM32DriverNode()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == "__main__":
    main()
--- File: ./src/car_hardware/car_hardware/__init__.py ---

--- File: ./src/car_hardware/car_hardware/servo_calibration_node.py ---
#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
import serial
import sys
import termios
import tty
import time

class ServoCalibrationNode(Node):
    def __init__(self):
        super().__init__('servo_calibration_node')

        # --- Parameters ---
        self.declare_parameter('serial_port', '/dev/ttyTHS1')
        self.declare_parameter('baud_rate', 115200)

        self.port = self.get_parameter('serial_port').value
        self.baud = self.get_parameter('baud_rate').value

        # --- Serial Connection ---
        # We open this DIRECTLY (bypassing the main driver) to get raw access
        try:
            self.serial = serial.Serial(self.port, self.baud, timeout=0.1)
            self.get_logger().info(f"Connected to STM32 on {self.port}")
        except Exception as e:
            self.get_logger().error(f"Failed to open serial port: {e}")
            sys.exit(1)

        self.servo_val = 90  # Start at center
        self.print_instructions()

    def print_instructions(self):
        print("\n========================================")
        print("   STM32 SERVO CALIBRATION NODE")
        print("========================================")
        print("Controls:")
        print("  [a]   Left  (-1)")
        print("  [d]   Right (+1)")
        print("  [A]   Left  (-5)")
        print("  [D]   Right (+5)")
        print("  [s]   Reset Center (90)")
        print("  [q]   Quit & Calculate Results")
        print("----------------------------------------")

    def get_key(self):
        """Reads a single keypress from stdin"""
        fd = sys.stdin.fileno()
        old_settings = termios.tcgetattr(fd)
        try:
            tty.setraw(sys.stdin.fileno())
            ch = sys.stdin.read(1)
        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
        return ch

    def send_cmd(self, angle):
        """Sends raw #CMD packet. Speed is always 0 during calibration."""
        # PACKET FORMAT: #CMD,speed,angle* (No newline \n)
        packet = f"#CMD,0,{angle}*"
        try:
            self.serial.write(packet.encode())
        except Exception as e:
            self.get_logger().warn(f"Serial write failed: {e}")

    def run(self):
        # Interactive Loop
        try:
            # Initial center command
            self.send_cmd(self.servo_val)
            print(f"\rCurrent Servo PWM: {self.servo_val}", end="")

            while rclpy.ok():
                key = self.get_key()
                
                if key == 'a':
                    self.servo_val -= 1
                elif key == 'd':
                    self.servo_val += 1
                elif key == 'A':
                    self.servo_val -= 5
                elif key == 'D':
                    self.servo_val += 5
                elif key == 's':
                    self.servo_val = 90
                elif key == 'q':
                    self.calculate_and_exit()
                    break
                elif key == '\x03': # Ctrl+C
                    break

                # Safety Clamp
                self.servo_val = max(0, min(180, self.servo_val))
                
                self.send_cmd(self.servo_val)
                print(f"\rCurrent Servo PWM: {self.servo_val}   ", end="")
                
        except Exception as e:
            print(e)
        finally:
            self.send_cmd(90) # Reset to safe center on exit
            if self.serial:
                self.serial.close()

    def calculate_and_exit(self):
        # Restore terminal settings for input()
        # (termios/tty messed them up for get_key)
        # We simply use print/input normally here as the loop is done.
        
        print("\n\n========================================")
        print("       CALIBRATION DATA ENTRY")
        print("========================================")
        
        try:
            # 1. CENTER
            print(f"1. Center PWM (Last position: {self.servo_val})")
            c_input = input(f"   Enter Center PWM [default {self.servo_val}]: ")
            val_center = int(c_input) if c_input else self.servo_val

            # 2. LEFT LIMIT
            print("\n2. Left Limit")
            val_left = int(input("   Enter PWM used for MAX LEFT: "))
            angle_left = float(input("   Enter Measured INNER Wheel Angle (deg): "))

            # 3. RIGHT LIMIT
            print("\n3. Right Limit")
            val_right = int(input("   Enter PWM used for MAX RIGHT: "))
            angle_right = float(input("   Enter Measured INNER Wheel Angle (deg): "))

            # Calculations
            # Ratio = Delta PWM / Angle
            ratio_l = abs(val_left - val_center) / angle_left
            ratio_r = abs(val_right - val_center) / angle_right
            avg_ratio = (ratio_l + ratio_r) / 2.0
            
            offset = val_center - 90

            self.get_logger().info("CALIBRATION COMPLETE")
            print("\n****************************************")
            print("   COPY THESE VALUES TO PYTHON DRIVER")
            print("****************************************")
            print(f"STEERING_RATIO = {avg_ratio:.2f}")
            print(f"SERVO_OFFSET   = {offset}")
            print(f"PWM_RANGE      = ({min(val_left, val_right)}, {max(val_left, val_right)})")
            print("****************************************")

        except ValueError:
            self.get_logger().error("Invalid input. Please enter numbers only.")

def main(args=None):
    rclpy.init(args=args)
    node = ServoCalibrationNode()
    
    # We don't use rclpy.spin() because we have a blocking input loop
    # The node handles its own loop in node.run()
    node.run()

    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
--- File: ./src/car_hardware/car_hardware/game_control_cli.py ---
#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist
import sys, select, termios, tty
import time
import numpy as np

# --- CONFIGURATION ---
REAL_MAX_SPEED_M_S = 1.0     # 1.0 m/s
REAL_WHEELBASE_M = 0.25      # 0.25m
STEER_LIMIT_DEG = 40.0       # Max steering angle
CMD_FREQ = 20.0              # Hz
LOOP_TIMEOUT = 1.0 / CMD_FREQ # New: Timeout used to control loop rate

# Physics / Feel
ACCEL_STEP = 0.05            # Speed increase per loop while holding W
BRAKE_STEP = 0.10            # Speed decrease per loop while holding S
STEER_STEP = 4.0             # Degrees change per loop
FRICTION   = 0.02            # Deceleration when key released
STEER_CENTERING = 2.0        # Auto-center steering when key released

# Timeout to detect "key release"
KEY_TIMEOUT = 0.15          

class KeyboardController(Node):
    def __init__(self):
        super().__init__('game_control_cli')
        self.publisher_ = self.create_publisher(Twist, 'cmd_vel', 10)
        
        # Save and set terminal settings once
        self.settings = termios.tcgetattr(sys.stdin)
        tty.setraw(sys.stdin.fileno()) # Set raw mode once for the duration of the node
        
        # State
        self.speed = 0.0     # -1.0 to 1.0
        self.steer = 0.0     # Degrees
        self.last_key_time = time.time()
        self.key_pressed = None

        print(f"""
        ---------------------------
          WASD GAME CONTROLLER
        ---------------------------
          W : Accelerate
          S : Brake / Reverse
          A : Steer Left
          D : Steer Right
        SPACE : E-Stop
        ---------------------------
        Running... Press Ctrl+C to quit.
        """)

    def get_key(self, timeout=LOOP_TIMEOUT):
        """Non-blocking keyboard read, assumes terminal is already in raw mode."""
        # Check for key press using select with a timeout
        rlist, _, _ = select.select([sys.stdin], [], [], timeout) 
        if rlist:
            # Read a character
            key = sys.stdin.read(1)
        else:
            key = ''
        return key

    def control_logic(self, key):
        """
        Calculates new speed/steer states based on key press 
        and publishes the Twist message.
        """
        
        # Determine user input
        if key in ['w', 's', 'a', 'd', ' ']:
            self.last_key_time = time.time()
            self.key_pressed = key
        elif key == '\x03': # Ctrl+C
            raise KeyboardInterrupt # Use an exception to cleanly exit the run loop
            
        # Check for key release (timeout)
        if time.time() - self.last_key_time > KEY_TIMEOUT:
            self.key_pressed = None

        # --- PHYSICS LOGIC ---
        
        # Throttle (W/S)
        if self.key_pressed == 'w':
            self.speed += ACCEL_STEP
        elif self.key_pressed == 's':
            self.speed -= BRAKE_STEP
        elif self.key_pressed == ' ':
            self.speed = 0.0
            self.steer = 0.0
        else:
            # Friction (Coast to stop)
            if self.speed > 0: self.speed -= FRICTION
            if self.speed < 0: self.speed += FRICTION
            if abs(self.speed) < FRICTION: self.speed = 0.0

        # Steering (A/D)
        if self.key_pressed == 'a':
            self.steer += STEER_STEP
        elif self.key_pressed == 'd':
            self.steer -= STEER_STEP
        else:
            # Auto-Center
            if self.steer > 0: self.steer -= STEER_CENTERING
            if self.steer < 0: self.steer += STEER_CENTERING
            if abs(self.steer) < STEER_CENTERING: self.steer = 0.0

        # Clamping
        self.speed = np.clip(self.speed, -1.0, 1.0)
        self.steer = np.clip(self.steer, -STEER_LIMIT_DEG, STEER_LIMIT_DEG)

        self.publish_cmd()

    def publish_cmd(self):
        msg = Twist()
        
        # Map percentage to real speed
        msg.linear.x = float(self.speed * REAL_MAX_SPEED_M_S)
        
        # Calculate Angular Velocity for Ackermann
        # w = (v * tan(theta)) / L
        steer_rad = np.radians(self.steer)
        
        # Small trick: Allow steering even if stopped (send tiny speed)
        # to prevent division by zero or logic errors in driver
        calc_speed = msg.linear.x if abs(msg.linear.x) > 0.01 else 0.01
        
        msg.angular.z = float((calc_speed * np.tan(steer_rad)) / REAL_WHEELBASE_M)

        self.publisher_.publish(msg)
        
        # Print status line (overwrite same line)
        sys.stdout.write(f"\rSpeed: {self.speed*100:3.0f}% | Steer: {self.steer:3.0f} deg   ")
        sys.stdout.flush()

    def run(self):
        """Main execution loop that replaces rclpy.spin() for teleop."""
        while rclpy.ok():
            try:
                # 1. Get key input (blocks for LOOP_TIMEOUT)
                key = self.get_key(timeout=LOOP_TIMEOUT)
                
                # 2. Process logic and publish
                self.control_logic(key)
                
                # 3. Allow ROS to process any pending callbacks (like timer/subscriptions if added later)
                rclpy.spin_once(self, timeout_sec=0) 
                
            except KeyboardInterrupt:
                break
            except Exception as e:
                self.get_logger().error(f'Runtime Error: {e}')
                break
        
        # Cleanup when the loop exits
        self.shutdown()


    def shutdown(self):
        print("\nStopping...")
        # Send zero velocity command
        msg = Twist()
        self.publisher_.publish(msg)
        
        # Restore terminal settings
        termios.tcsetattr(sys.stdin, termios.TCSADRAIN, self.settings)
        
        self.destroy_node()
        rclpy.shutdown()
        sys.exit(0) # Exit cleanly

def main():
    rclpy.init()
    node = KeyboardController()
    node.run() # Start the main control loop

if __name__ == '__main__':
    main()
--- File: ./src/car_hardware/car_hardware/teleop_keyboard_node.py ---
#!/usr/bin/env python3
"""
Keyboard Teleop Node for RC Car
"""

import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist
import sys
import select
import termios
import tty

INSTRUCTIONS = """
RC Car Keyboard Control
-----------------------
   w
a  s  d

w/s : increase/decrease speed
a/d : turn left/right
space : stop
q : quit

CTRL-C to quit
"""

class TeleopKeyboardNode(Node):
    def __init__(self):
        super().__init__('teleop_keyboard_node')
        
        # Parameters
        self.declare_parameter('speed_step', 0.1)
        self.declare_parameter('turn_step', 0.3)
        self.declare_parameter('max_speed', 1.0)
        self.declare_parameter('max_turn', 1.0)
        
        self.speed_step = self.get_parameter('speed_step').value
        self.turn_step = self.get_parameter('turn_step').value
        self.max_speed = self.get_parameter('max_speed').value
        self.max_turn = self.get_parameter('max_turn').value
        
        # Publisher
        self.cmd_vel_pub = self.create_publisher(Twist, 'cmd_vel', 10)
        
        # Current velocities
        self.linear_vel = 0.0
        self.angular_vel = 0.0
        
        # Terminal settings
        self.settings = termios.tcgetattr(sys.stdin)
        
        self.get_logger().info('Teleop Keyboard Node initialized')
        print(INSTRUCTIONS)
    
    def get_key(self, timeout=0.1):
        """Get keyboard input"""
        tty.setraw(sys.stdin.fileno())
        rlist, _, _ = select.select([sys.stdin], [], [], timeout)
        if rlist:
            key = sys.stdin.read(1)
        else:
            key = ''
        termios.tcsetattr(sys.stdin, termios.TCSADRAIN, self.settings)
        return key
    
    def publish_twist(self):
        """Publish velocity"""
        twist = Twist()
        twist.linear.x = self.linear_vel
        twist.angular.z = self.angular_vel
        self.cmd_vel_pub.publish(twist)
        print(f'\rSpeed: {self.linear_vel:.2f} m/s | Turn: {self.angular_vel:.2f} rad/s', end='')
    
    def run(self):
        """Main loop"""
        try:
            while rclpy.ok():
                key = self.get_key()
                
                if key == 'w':
                    self.linear_vel = min(self.linear_vel + self.speed_step, self.max_speed)
                elif key == 's':
                    self.linear_vel = max(self.linear_vel - self.speed_step, -self.max_speed)
                elif key == 'a':
                    self.angular_vel = min(self.angular_vel + self.turn_step, self.max_turn)
                elif key == 'd':
                    self.angular_vel = max(self.angular_vel - self.turn_step, -self.max_turn)
                elif key == ' ':
                    self.linear_vel = 0.0
                    self.angular_vel = 0.0
                elif key == 'q':
                    break
                
                self.publish_twist()
                
        except Exception as e:
            self.get_logger().error(f'Error: {e}')
        finally:
            self.linear_vel = 0.0
            self.angular_vel = 0.0
            self.publish_twist()
            termios.tcsetattr(sys.stdin, termios.TCSADRAIN, self.settings)


def main(args=None):
    rclpy.init(args=args)
    node = TeleopKeyboardNode()
    
    try:
        node.run()
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()

--- File: ./src/car_hardware/test/test_copyright.py ---
# Copyright 2015 Open Source Robotics Foundation, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from ament_copyright.main import main
import pytest


# Remove the `skip` decorator once the source file(s) have a copyright header
@pytest.mark.skip(reason='No copyright header has been placed in the generated source file.')
@pytest.mark.copyright
@pytest.mark.linter
def test_copyright():
    rc = main(argv=['.', 'test'])
    assert rc == 0, 'Found errors'

--- File: ./src/car_hardware/test/test_pep257.py ---
# Copyright 2015 Open Source Robotics Foundation, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from ament_pep257.main import main
import pytest


@pytest.mark.linter
@pytest.mark.pep257
def test_pep257():
    rc = main(argv=['.', 'test'])
    assert rc == 0, 'Found code style errors / warnings'

--- File: ./src/car_hardware/test/test_flake8.py ---
# Copyright 2017 Open Source Robotics Foundation, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from ament_flake8.main import main_with_errors
import pytest


@pytest.mark.flake8
@pytest.mark.linter
def test_flake8():
    rc, errors = main_with_errors(argv=[])
    assert rc == 0, \
        'Found %d code style errors / warnings:\n' % len(errors) + \
        '\n'.join(errors)

--- File: ./codebase.txt ---

--- File: ./create_codebase.sh ---
#!/bin/bash

# A script to convert a codebase into a single text file with hierarchy,
# ignoring specified files and directories.

# Set the output file name
OUTPUT_FILE="codebase.txt"

# Set the root directory of your codebase
# By default, it uses the current directory where the script is run
CODE_ROOT_DIR="."

# Define the files and directories to ignore ðŸš«
# IMPORTANT: Directories MUST end with a trailing slash to be correctly ignored.
# This tells the script's logic to use the efficient -prune option.
EXCLUDE_LIST=(
    ".git/"
    "node_modules/"
    "__pycache__/"
    "dist/"
    "*.log"
    "*.pyc"
    "*.avi"
    "build/"
    "install/"
    "log"
    "README.md"
)

# Clear the output file if it exists
> "$OUTPUT_FILE"

echo "Generating codebase hierarchy..."
# Convert the bash array to a format 'tree' understands: 'pattern1|pattern2|...'
EXCLUDE_STRING=$(printf "%s|" "${EXCLUDE_LIST[@]}")
EXCLUDE_STRING=${EXCLUDE_STRING%?} # Remove the last pipe character

# Use 'tree' with the -I option to exclude directories and files
tree -a -I "$EXCLUDE_STRING" "$CODE_ROOT_DIR" >> "$OUTPUT_FILE"

echo "" >> "$OUTPUT_FILE"
echo "==========================================" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

echo "Concatenating file contents..."

# Build the find command dynamically to apply exclusions correctly
FIND_CMD="find \"$CODE_ROOT_DIR\""

# Add the exclusion logic for each item
for item in "${EXCLUDE_LIST[@]}"; do
    if [[ "$item" == */ ]]; then
        # This is a directory, use -prune to skip it and its contents
        FIND_CMD+=" -path \"$CODE_ROOT_DIR/${item%?}\" -prune -o"
    else
        # This is a file, use ! -name to exclude it
        FIND_CMD+=" -name \"$item\" -prune -o"
    fi
done

# Add the final -type f to select only files that haven't been pruned
FIND_CMD+=" -type f -print0"

# Use eval to execute the dynamically built find command, and pipe to while loop
eval "$FIND_CMD" | while IFS= read -r -d $'\0' file; do
    echo "--- File: $file ---" >> "$OUTPUT_FILE"
    cat "$file" >> "$OUTPUT_FILE"
    echo "" >> "$OUTPUT_FILE" # Add a newline for separation
done

echo "Done! Codebase has been exported to $OUTPUT_FILE"

--- File: ./.gitignore ---
build/
install/
log/
.vscode/

