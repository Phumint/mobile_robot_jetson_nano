
==========================================

--- File: ./src/car_bringup/launch/sensors.launch.py ---
#!/usr/bin/env python3

from launch import LaunchDescription
from launch_ros.actions import Node
from launch.actions import DeclareLaunchArgument
from launch.substitutions import LaunchConfiguration

def generate_launch_description():
    
    serial_port_arg = DeclareLaunchArgument(
        'serial_port',
        default_value='/dev/ttyTHS1',
        description='Serial port for STM32'
    )
    
    # STM32 Driver Node (sensors only mode)
    stm32_driver = Node(
        package='car_hardware',
        executable='stm32_driver',
        name='stm32_driver_node',
        output='screen',
        parameters=[{
            'serial_port': LaunchConfiguration('serial_port'),
            'baud_rate': 115200
        }]
    )
    
    return LaunchDescription([
        serial_port_arg,
        stm32_driver,
    ])

--- File: ./src/car_bringup/launch/teleop.launch.py ---
#!/usr/bin/env python3

from launch import LaunchDescription
from launch_ros.actions import Node
from launch.actions import DeclareLaunchArgument
from launch.substitutions import LaunchConfiguration

def generate_launch_description():
    
    # Declare arguments
    serial_port_arg = DeclareLaunchArgument(
        'serial_port',
        default_value='/dev/ttyTHS1',
        description='Serial port for STM32'
    )
    
    # STM32 Driver Node
    stm32_driver = Node(
        package='car_hardware',
        executable='stm32_driver',
        name='stm32_driver_node',
        output='screen',
        parameters=[{
            'serial_port': LaunchConfiguration('serial_port'),
            'baud_rate': 115200,
            'wheel_base': 0.25,
            'max_speed': 1.0,
            'max_steering_angle': 40.0
        }]
    )
    
    # Teleop Keyboard Node
    teleop_keyboard = Node(
        package='car_hardware',
        executable='teleop_keyboard',
        name='teleop_keyboard_node',
        output='screen',
        parameters=[{
            'speed_step': 0.1,
            'turn_step': 0.3,
            'max_speed': 1.0,
            'max_turn': 1.0
        }],
        prefix='xterm -e'  # Run in separate terminal
    )
    
    return LaunchDescription([
        serial_port_arg,
        stm32_driver,
        # teleop_keyboard,  # Uncomment to auto-launch teleop
    ])

--- File: ./src/car_bringup/package.xml ---
<?xml version="1.0"?>
<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
<package format="3">
  <name>car_bringup</name>
  <version>0.0.0</version>
  <description>TODO: Package description</description>
  <maintainer email="root@todo.todo">root</maintainer>
  <license>TODO: License declaration</license>

  <buildtool_depend>ament_cmake</buildtool_depend>

  <test_depend>ament_lint_auto</test_depend>
  <test_depend>ament_lint_common</test_depend>

  <export>
    <build_type>ament_cmake</build_type>
  </export>
</package>

--- File: ./src/car_bringup/CMakeLists.txt ---
cmake_minimum_required(VERSION 3.8)
project(car_bringup)

if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
  add_compile_options(-Wall -Wextra -Wpedantic)
endif()

# find dependencies
find_package(ament_cmake REQUIRED)

# Install launch files
install(DIRECTORY
  launch
  config
  DESTINATION share/${PROJECT_NAME}/
)

if(BUILD_TESTING)
  find_package(ament_lint_auto REQUIRED)
  ament_lint_auto_find_test_dependencies()
endif()

ament_package()

--- File: ./src/car_hardware/resource/car_hardware ---

--- File: ./src/car_hardware/package.xml ---
<?xml version="1.0"?>
<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
<package format="3">
  <name>car_hardware</name>
  <version>0.0.0</version>
  <description>TODO: Package description</description>
  <maintainer email="root@todo.todo">root</maintainer>
  <license>TODO: License declaration</license>

  <depend>rclpy</depend>
  <depend>geometry_msgs</depend>
  <depend>sensor_msgs</depend>
  <depend>std_msgs</depend>
  <depend>nav_msgs</depend>

  <test_depend>ament_copyright</test_depend>
  <test_depend>ament_flake8</test_depend>
  <test_depend>ament_pep257</test_depend>
  <test_depend>python3-pytest</test_depend>

  <export>
    <build_type>ament_python</build_type>
  </export>
</package>

--- File: ./src/car_hardware/setup.py ---
from setuptools import setup
import os
from glob import glob

package_name = 'car_hardware'

setup(
    name=package_name,
    version='0.0.1',
    packages=[package_name],
    data_files=[
        ('share/ament_index/resource_index/packages',
            ['resource/' + package_name]),
        ('share/' + package_name, ['package.xml']),
    ],
    install_requires=['setuptools'],
    zip_safe=True,
    maintainer='your_name',
    maintainer_email='your_email@example.com',
    description='Hardware interface for RC car',
    license='MIT',
    tests_require=['pytest'],
    entry_points={
        'console_scripts': [
            'stm32_driver = car_hardware.stm32_driver_node:main',
            'teleop_keyboard = car_hardware.teleop_keyboard_node:main',
            'game_control_cli = car_hardware.game_control_cli:main',

        ],
    },
)

--- File: ./src/car_hardware/setup.cfg ---
[develop]
script_dir=$base/lib/car_hardware
[install]
install_scripts=$base/lib/car_hardware

--- File: ./src/car_hardware/car_hardware/stm32_driver_node.py ---
#!/usr/bin/env python3
"""
STM32 Driver Node (Optimized)
Improvements: 
1. Dynamic dt calculation for accurate Yaw integration.
2. Allows steering wheels to turn even when stopped.
3. Thread-safe serial writes.
4. Robust shutdown procedure.
"""

import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist
from sensor_msgs.msg import Imu
from std_msgs.msg import Int32
import serial
import threading
import math
import time

class STM32DriverNode(Node):
    def __init__(self):
        super().__init__('stm32_driver_node')

        # --- Parameters ---
        self.declare_parameter('serial_port', '/dev/ttyTHS1')
        self.declare_parameter('baud_rate', 115200)
        self.declare_parameter('wheel_base', 0.25)
        self.declare_parameter('max_speed_m_s', 1.0) # Renamed for clarity
        self.declare_parameter('max_steering_angle_deg', 40.0)

        self.port = self.get_parameter('serial_port').value
        self.baud = self.get_parameter('baud_rate').value
        self.wheel_base = self.get_parameter('wheel_base').value
        self.max_speed = self.get_parameter('max_speed_m_s').value
        self.max_steer = self.get_parameter('max_steering_angle_deg').value

        # --- Serial Connection ---
        self.serial = None
        self.serial_lock = threading.Lock() # Prevent read/write collisions
        self._open_serial()

        # --- ROS2 Interfaces ---
        self.encoder_pub = self.create_publisher(Int32, 'encoder_count', 10)
        self.imu_pub = self.create_publisher(Imu, 'imu/data_raw', 10)
        
        self.cmd_vel_sub = self.create_subscription(
            Twist, 'cmd_vel', self.cmd_vel_callback, 10
        )

        # --- State Variables ---
        self.last_imu_time = self.get_clock().now()
        self.integrated_yaw = 0.0
        
        # --- Threading ---
        self.running = True
        self.read_thread = threading.Thread(target=self.serial_read_loop, daemon=True)
        self.read_thread.start()

        self.get_logger().info("STM32 Driver Node initialized.")

    def _open_serial(self):
        try:
            if self.serial and self.serial.is_open:
                self.serial.close()
            self.serial = serial.Serial(self.port, self.baud, timeout=0.1)
            self.get_logger().info(f"Connected to STM32 on {self.port}")
        except Exception as e:
            self.get_logger().error(f"Failed to open serial port: {e}")
            self.serial = None

    # ---------------------------
    #  CMD_VEL CALLBACK (Control)
    # ---------------------------
    def cmd_vel_callback(self, msg):
        linear = msg.linear.x
        angular = msg.angular.z

        # 1. Calculate Steering (Ackermann)
        # We allow steering even if linear speed is 0 (maneuvering)
        if abs(angular) > 0.001:
            # Avoid division by zero: assume a tiny velocity if stopped
            safe_linear = linear if abs(linear) > 0.01 else 0.01
            # tan(theta) = (angular_vel * wheelbase) / linear_vel
            steering_rad = math.atan((angular * self.wheel_base) / safe_linear)
            
            # If reversing, the steering direction logic flips in some models,
            # but usually for a standard car, the servo angle remains physically consistent.
            # We keep it standard here.
            steering_deg = math.degrees(steering_rad)
        else:
            steering_deg = 0.0

        # Clamp steering
        steering_deg = max(-self.max_steer, min(self.max_steer, steering_deg))

        # Map to Servo (90 is center, 50-130 range)
        # Note: Check if positive steering_deg should be Left or Right for your specific servo
        servo_cmd = 90 - int(steering_deg) 
        servo_cmd = max(50, min(130, servo_cmd))

        # 2. Calculate Motor Speed
        # Map m/s to -100 to 100 PWM
        speed_cmd = int((linear / self.max_speed) * 100)
        speed_cmd = max(-100, min(100, speed_cmd))

        self.send_packet(speed_cmd, servo_cmd)

    def send_packet(self, speed, angle):
        if not self.serial:
            return
        
        packet = f"#CMD,{speed},{angle}*\n" # Added \n for robustness
        try:
            with self.serial_lock:
                self.serial.write(packet.encode())
        except Exception as e:
            self.get_logger().warn(f"Serial write failed: {e}")
            self._open_serial()

    # ---------------------------
    #  SERIAL READ LOOP
    # ---------------------------
    def serial_read_loop(self):
        while self.running and rclpy.ok():
            if not self.serial:
                time.sleep(1)
                self._open_serial()
                continue

            try:
                # readline blocks for timeout (0.1s)
                line = self.serial.readline().decode('utf-8', errors='ignore').strip()
                
                if not line:
                    continue # Timeout or empty

                # Validate Packet Format
                if line.startswith('$') and line.endswith('*'):
                    self.parse_sensor_data(line)
            
            except serial.SerialException:
                self.get_logger().error("Serial connection lost.")
                self.serial.close()
                self.serial = None
            except Exception as e:
                self.get_logger().warn(f"Read error: {e}")

    # ---------------------------
    #  PARSING & PUBLISHING
    # ---------------------------
    def parse_sensor_data(self, line):
        # Format: $ENC,12345;IMU,ax,ay,az,gx,gy,gz,roll,pitch*
        try:
            content = line[1:-1] # Strip $ and *
            parts = content.split(';')
            
            for part in parts:
                if part.startswith("ENC"):
                    self.handle_encoder(part)
                elif part.startswith("IMU"):
                    self.handle_imu(part)
        except ValueError:
            pass # Malformed numbers

    def handle_encoder(self, part):
        # part = "ENC,12345"
        try:
            val = int(part.split(',')[1])
            msg = Int32()
            msg.data = val
            self.encoder_pub.publish(msg)
        except IndexError:
            pass

    def handle_imu(self, part):
        # part = "IMU,ax,ay,az,gx,gy,gz,roll,pitch" (integers scaled)
        # SCALING MUST MATCH STM32 CODE:
        # Accel / 1000.0, Gyro / 100.0, Euler / 100.0
        vals = part.split(',')[1:]
        if len(vals) < 8: return

        ax = float(vals[0]) / 1000.0
        ay = float(vals[1]) / 1000.0
        az = float(vals[2]) / 1000.0
        gx = float(vals[3]) / 100.0
        gy = float(vals[4]) / 100.0
        gz = float(vals[5]) / 100.0
        # roll/pitch ignored for orientation calculation 
        # because we calculate quaternion from gyro integration + accel usually, 
        # but here we just use what we have.

        # --- Dynamic Time Integration ---
        current_time = self.get_clock().now()
        dt = (current_time - self.last_imu_time).nanoseconds / 1e9
        self.last_imu_time = current_time

        # Avoid integration spikes if connection lagged
        if dt > 1.0: dt = 0.0 

        # Integrate Yaw (Gyro Z)
        self.integrated_yaw += math.radians(gz) * dt

        self.publish_imu_msg(ax, ay, az, gx, gy, gz)

    def publish_imu_msg(self, ax, ay, az, gx, gy, gz):
        msg = Imu()
        msg.header.stamp = self.get_clock().now().to_msg()
        msg.header.frame_id = "imu_link"

        # Linear Accel
        msg.linear_acceleration.x = ax * 9.81
        msg.linear_acceleration.y = ay * 9.81
        msg.linear_acceleration.z = az * 9.81

        # Angular Velocity
        msg.angular_velocity.x = math.radians(gx)
        msg.angular_velocity.y = math.radians(gy)
        msg.angular_velocity.z = math.radians(gz)

        # Orientation (Quaternion from Yaw only for planar robot)
        # Assuming the robot stays mostly flat, we simplify to Yaw rotation
        cy = math.cos(self.integrated_yaw * 0.5)
        sy = math.sin(self.integrated_yaw * 0.5)
        
        # Simple Yaw-only Quaternion (w, x, y, z)
        msg.orientation.w = cy
        msg.orientation.x = 0.0
        msg.orientation.y = 0.0
        msg.orientation.z = sy

        self.imu_pub.publish(msg)

    def destroy_node(self):
        self.running = False
        # Stop the robot on shutdown
        self.send_packet(0, 90) 
        if self.serial:
            self.serial.close()
        super().destroy_node()

def main(args=None):
    rclpy.init(args=args)
    node = STM32DriverNode()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == "__main__":
    main()
--- File: ./src/car_hardware/car_hardware/__init__.py ---

--- File: ./src/car_hardware/car_hardware/game_control_cli.py ---
#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist
import sys, select, termios, tty
import time
import numpy as np

# --- CONFIGURATION ---
REAL_MAX_SPEED_M_S = 1.0     # 1.0 m/s
REAL_WHEELBASE_M = 0.25      # 0.25m
STEER_LIMIT_DEG = 40.0       # Max steering angle
CMD_FREQ = 20.0              # Hz
LOOP_TIMEOUT = 1.0 / CMD_FREQ # New: Timeout used to control loop rate

# Physics / Feel
ACCEL_STEP = 0.05            # Speed increase per loop while holding W
BRAKE_STEP = 0.10            # Speed decrease per loop while holding S
STEER_STEP = 4.0             # Degrees change per loop
FRICTION   = 0.02            # Deceleration when key released
STEER_CENTERING = 2.0        # Auto-center steering when key released

# Timeout to detect "key release"
KEY_TIMEOUT = 0.15          

class KeyboardController(Node):
    def __init__(self):
        super().__init__('game_control_cli')
        self.publisher_ = self.create_publisher(Twist, 'cmd_vel', 10)
        
        # Save and set terminal settings once
        self.settings = termios.tcgetattr(sys.stdin)
        tty.setraw(sys.stdin.fileno()) # Set raw mode once for the duration of the node
        
        # State
        self.speed = 0.0     # -1.0 to 1.0
        self.steer = 0.0     # Degrees
        self.last_key_time = time.time()
        self.key_pressed = None

        print(f"""
        ---------------------------
          WASD GAME CONTROLLER
        ---------------------------
          W : Accelerate
          S : Brake / Reverse
          A : Steer Left
          D : Steer Right
        SPACE : E-Stop
        ---------------------------
        Running... Press Ctrl+C to quit.
        """)

    def get_key(self, timeout=LOOP_TIMEOUT):
        """Non-blocking keyboard read, assumes terminal is already in raw mode."""
        # Check for key press using select with a timeout
        rlist, _, _ = select.select([sys.stdin], [], [], timeout) 
        if rlist:
            # Read a character
            key = sys.stdin.read(1)
        else:
            key = ''
        return key

    def control_logic(self, key):
        """
        Calculates new speed/steer states based on key press 
        and publishes the Twist message.
        """
        
        # Determine user input
        if key in ['w', 's', 'a', 'd', ' ']:
            self.last_key_time = time.time()
            self.key_pressed = key
        elif key == '\x03': # Ctrl+C
            raise KeyboardInterrupt # Use an exception to cleanly exit the run loop
            
        # Check for key release (timeout)
        if time.time() - self.last_key_time > KEY_TIMEOUT:
            self.key_pressed = None

        # --- PHYSICS LOGIC ---
        
        # Throttle (W/S)
        if self.key_pressed == 'w':
            self.speed += ACCEL_STEP
        elif self.key_pressed == 's':
            self.speed -= BRAKE_STEP
        elif self.key_pressed == ' ':
            self.speed = 0.0
            self.steer = 0.0
        else:
            # Friction (Coast to stop)
            if self.speed > 0: self.speed -= FRICTION
            if self.speed < 0: self.speed += FRICTION
            if abs(self.speed) < FRICTION: self.speed = 0.0

        # Steering (A/D)
        if self.key_pressed == 'a':
            self.steer += STEER_STEP
        elif self.key_pressed == 'd':
            self.steer -= STEER_STEP
        else:
            # Auto-Center
            if self.steer > 0: self.steer -= STEER_CENTERING
            if self.steer < 0: self.steer += STEER_CENTERING
            if abs(self.steer) < STEER_CENTERING: self.steer = 0.0

        # Clamping
        self.speed = np.clip(self.speed, -1.0, 1.0)
        self.steer = np.clip(self.steer, -STEER_LIMIT_DEG, STEER_LIMIT_DEG)

        self.publish_cmd()

    def publish_cmd(self):
        msg = Twist()
        
        # Map percentage to real speed
        msg.linear.x = float(self.speed * REAL_MAX_SPEED_M_S)
        
        # Calculate Angular Velocity for Ackermann
        # w = (v * tan(theta)) / L
        steer_rad = np.radians(self.steer)
        
        # Small trick: Allow steering even if stopped (send tiny speed)
        # to prevent division by zero or logic errors in driver
        calc_speed = msg.linear.x if abs(msg.linear.x) > 0.01 else 0.01
        
        msg.angular.z = float((calc_speed * np.tan(steer_rad)) / REAL_WHEELBASE_M)

        self.publisher_.publish(msg)
        
        # Print status line (overwrite same line)
        sys.stdout.write(f"\rSpeed: {self.speed*100:3.0f}% | Steer: {self.steer:3.0f} deg   ")
        sys.stdout.flush()

    def run(self):
        """Main execution loop that replaces rclpy.spin() for teleop."""
        while rclpy.ok():
            try:
                # 1. Get key input (blocks for LOOP_TIMEOUT)
                key = self.get_key(timeout=LOOP_TIMEOUT)
                
                # 2. Process logic and publish
                self.control_logic(key)
                
                # 3. Allow ROS to process any pending callbacks (like timer/subscriptions if added later)
                rclpy.spin_once(self, timeout_sec=0) 
                
            except KeyboardInterrupt:
                break
            except Exception as e:
                self.get_logger().error(f'Runtime Error: {e}')
                break
        
        # Cleanup when the loop exits
        self.shutdown()


    def shutdown(self):
        print("\nStopping...")
        # Send zero velocity command
        msg = Twist()
        self.publisher_.publish(msg)
        
        # Restore terminal settings
        termios.tcsetattr(sys.stdin, termios.TCSADRAIN, self.settings)
        
        self.destroy_node()
        rclpy.shutdown()
        sys.exit(0) # Exit cleanly

def main():
    rclpy.init()
    node = KeyboardController()
    node.run() # Start the main control loop

if __name__ == '__main__':
    main()
--- File: ./src/car_hardware/car_hardware/teleop_keyboard_node.py ---
#!/usr/bin/env python3
"""
Keyboard Teleop Node for RC Car
"""

import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist
import sys
import select
import termios
import tty

INSTRUCTIONS = """
RC Car Keyboard Control
-----------------------
   w
a  s  d

w/s : increase/decrease speed
a/d : turn left/right
space : stop
q : quit

CTRL-C to quit
"""

class TeleopKeyboardNode(Node):
    def __init__(self):
        super().__init__('teleop_keyboard_node')
        
        # Parameters
        self.declare_parameter('speed_step', 0.1)
        self.declare_parameter('turn_step', 0.3)
        self.declare_parameter('max_speed', 1.0)
        self.declare_parameter('max_turn', 1.0)
        
        self.speed_step = self.get_parameter('speed_step').value
        self.turn_step = self.get_parameter('turn_step').value
        self.max_speed = self.get_parameter('max_speed').value
        self.max_turn = self.get_parameter('max_turn').value
        
        # Publisher
        self.cmd_vel_pub = self.create_publisher(Twist, 'cmd_vel', 10)
        
        # Current velocities
        self.linear_vel = 0.0
        self.angular_vel = 0.0
        
        # Terminal settings
        self.settings = termios.tcgetattr(sys.stdin)
        
        self.get_logger().info('Teleop Keyboard Node initialized')
        print(INSTRUCTIONS)
    
    def get_key(self, timeout=0.1):
        """Get keyboard input"""
        tty.setraw(sys.stdin.fileno())
        rlist, _, _ = select.select([sys.stdin], [], [], timeout)
        if rlist:
            key = sys.stdin.read(1)
        else:
            key = ''
        termios.tcsetattr(sys.stdin, termios.TCSADRAIN, self.settings)
        return key
    
    def publish_twist(self):
        """Publish velocity"""
        twist = Twist()
        twist.linear.x = self.linear_vel
        twist.angular.z = self.angular_vel
        self.cmd_vel_pub.publish(twist)
        print(f'\rSpeed: {self.linear_vel:.2f} m/s | Turn: {self.angular_vel:.2f} rad/s', end='')
    
    def run(self):
        """Main loop"""
        try:
            while rclpy.ok():
                key = self.get_key()
                
                if key == 'w':
                    self.linear_vel = min(self.linear_vel + self.speed_step, self.max_speed)
                elif key == 's':
                    self.linear_vel = max(self.linear_vel - self.speed_step, -self.max_speed)
                elif key == 'a':
                    self.angular_vel = min(self.angular_vel + self.turn_step, self.max_turn)
                elif key == 'd':
                    self.angular_vel = max(self.angular_vel - self.turn_step, -self.max_turn)
                elif key == ' ':
                    self.linear_vel = 0.0
                    self.angular_vel = 0.0
                elif key == 'q':
                    break
                
                self.publish_twist()
                
        except Exception as e:
            self.get_logger().error(f'Error: {e}')
        finally:
            self.linear_vel = 0.0
            self.angular_vel = 0.0
            self.publish_twist()
            termios.tcsetattr(sys.stdin, termios.TCSADRAIN, self.settings)


def main(args=None):
    rclpy.init(args=args)
    node = TeleopKeyboardNode()
    
    try:
        node.run()
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()

--- File: ./src/car_hardware/test/test_copyright.py ---
# Copyright 2015 Open Source Robotics Foundation, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from ament_copyright.main import main
import pytest


# Remove the `skip` decorator once the source file(s) have a copyright header
@pytest.mark.skip(reason='No copyright header has been placed in the generated source file.')
@pytest.mark.copyright
@pytest.mark.linter
def test_copyright():
    rc = main(argv=['.', 'test'])
    assert rc == 0, 'Found errors'

--- File: ./src/car_hardware/test/test_pep257.py ---
# Copyright 2015 Open Source Robotics Foundation, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from ament_pep257.main import main
import pytest


@pytest.mark.linter
@pytest.mark.pep257
def test_pep257():
    rc = main(argv=['.', 'test'])
    assert rc == 0, 'Found code style errors / warnings'

--- File: ./src/car_hardware/test/test_flake8.py ---
# Copyright 2017 Open Source Robotics Foundation, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from ament_flake8.main import main_with_errors
import pytest


@pytest.mark.flake8
@pytest.mark.linter
def test_flake8():
    rc, errors = main_with_errors(argv=[])
    assert rc == 0, \
        'Found %d code style errors / warnings:\n' % len(errors) + \
        '\n'.join(errors)

--- File: ./codebase.txt ---

--- File: ./create_codebase.sh ---
#!/bin/bash

# A script to convert a codebase into a single text file with hierarchy,
# ignoring specified files and directories.

# Set the output file name
OUTPUT_FILE="codebase.txt"

# Set the root directory of your codebase
# By default, it uses the current directory where the script is run
CODE_ROOT_DIR="."

# Define the files and directories to ignore ðŸš«
# IMPORTANT: Directories MUST end with a trailing slash to be correctly ignored.
# This tells the script's logic to use the efficient -prune option.
EXCLUDE_LIST=(
    ".git/"
    "node_modules/"
    "__pycache__/"
    "dist/"
    "*.log"
    "*.pyc"
    "*.avi"
    "build/"
    "install/"
    "log"
    "README.md"
)

# Clear the output file if it exists
> "$OUTPUT_FILE"

echo "Generating codebase hierarchy..."
# Convert the bash array to a format 'tree' understands: 'pattern1|pattern2|...'
EXCLUDE_STRING=$(printf "%s|" "${EXCLUDE_LIST[@]}")
EXCLUDE_STRING=${EXCLUDE_STRING%?} # Remove the last pipe character

# Use 'tree' with the -I option to exclude directories and files
tree -a -I "$EXCLUDE_STRING" "$CODE_ROOT_DIR" >> "$OUTPUT_FILE"

echo "" >> "$OUTPUT_FILE"
echo "==========================================" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

echo "Concatenating file contents..."

# Build the find command dynamically to apply exclusions correctly
FIND_CMD="find \"$CODE_ROOT_DIR\""

# Add the exclusion logic for each item
for item in "${EXCLUDE_LIST[@]}"; do
    if [[ "$item" == */ ]]; then
        # This is a directory, use -prune to skip it and its contents
        FIND_CMD+=" -path \"$CODE_ROOT_DIR/${item%?}\" -prune -o"
    else
        # This is a file, use ! -name to exclude it
        FIND_CMD+=" -name \"$item\" -prune -o"
    fi
done

# Add the final -type f to select only files that haven't been pruned
FIND_CMD+=" -type f -print0"

# Use eval to execute the dynamically built find command, and pipe to while loop
eval "$FIND_CMD" | while IFS= read -r -d $'\0' file; do
    echo "--- File: $file ---" >> "$OUTPUT_FILE"
    cat "$file" >> "$OUTPUT_FILE"
    echo "" >> "$OUTPUT_FILE" # Add a newline for separation
done

echo "Done! Codebase has been exported to $OUTPUT_FILE"

--- File: ./.gitignore ---
build/
install/
log/
.vscode/

