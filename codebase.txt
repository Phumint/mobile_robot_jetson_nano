.
├── build
│   ├── .built_by
│   ├── car_autonomy
│   │   ├── build
│   │   │   └── lib
│   │   │       └── car_autonomy
│   │   │           ├── __init__.py
│   │   │           ├── lane_detection.py
│   │   │           └── lane_follower.py
│   │   ├── car_autonomy.egg-info
│   │   │   ├── dependency_links.txt
│   │   │   ├── entry_points.txt
│   │   │   ├── PKG-INFO
│   │   │   ├── requires.txt
│   │   │   ├── SOURCES.txt
│   │   │   ├── top_level.txt
│   │   │   └── zip-safe
│   │   ├── colcon_build.rc
│   │   ├── colcon_command_prefix_setup_py.sh
│   │   ├── colcon_command_prefix_setup_py.sh.env
│   │   └── prefix_override
│   │       ├── __pycache__
│   │       └── sitecustomize.py
│   ├── car_bringup
│   │   ├── ament_cmake_core
│   │   │   ├── car_bringupConfig.cmake
│   │   │   ├── car_bringupConfig-version.cmake
│   │   │   ├── package.cmake
│   │   │   └── stamps
│   │   │       ├── ament_prefix_path.sh.stamp
│   │   │       ├── nameConfig.cmake.in.stamp
│   │   │       ├── nameConfig-version.cmake.in.stamp
│   │   │       ├── package_xml_2_cmake.py.stamp
│   │   │       ├── package.xml.stamp
│   │   │       ├── path.sh.stamp
│   │   │       └── templates_2_cmake.py.stamp
│   │   ├── ament_cmake_environment_hooks
│   │   │   ├── ament_prefix_path.dsv
│   │   │   ├── local_setup.bash
│   │   │   ├── local_setup.dsv
│   │   │   ├── local_setup.sh
│   │   │   ├── local_setup.zsh
│   │   │   ├── package.dsv
│   │   │   └── path.dsv
│   │   ├── ament_cmake_index
│   │   │   └── share
│   │   │       └── ament_index
│   │   │           └── resource_index
│   │   │               ├── package_run_dependencies
│   │   │               │   └── car_bringup
│   │   │               ├── packages
│   │   │               │   └── car_bringup
│   │   │               └── parent_prefix_path
│   │   │                   └── car_bringup
│   │   ├── ament_cmake_package_templates
│   │   │   └── templates.cmake
│   │   ├── ament_cmake_uninstall_target
│   │   │   └── ament_cmake_uninstall_target.cmake
│   │   ├── ament_copyright
│   │   ├── ament_flake8
│   │   ├── ament_lint_cmake
│   │   ├── ament_pep257
│   │   ├── ament_xmllint
│   │   ├── cmake_args.last
│   │   ├── CMakeCache.txt
│   │   ├── CMakeFiles
│   │   │   ├── 3.27.9
│   │   │   │   ├── CMakeCCompiler.cmake
│   │   │   │   ├── CMakeCXXCompiler.cmake
│   │   │   │   ├── CMakeDetermineCompilerABI_C.bin
│   │   │   │   ├── CMakeDetermineCompilerABI_CXX.bin
│   │   │   │   ├── CMakeSystem.cmake
│   │   │   │   ├── CompilerIdC
│   │   │   │   │   ├── a.out
│   │   │   │   │   ├── CMakeCCompilerId.c
│   │   │   │   │   └── tmp
│   │   │   │   └── CompilerIdCXX
│   │   │   │       ├── a.out
│   │   │   │       ├── CMakeCXXCompilerId.cpp
│   │   │   │       └── tmp
│   │   │   ├── car_bringup_uninstall.dir
│   │   │   │   ├── build.make
│   │   │   │   ├── cmake_clean.cmake
│   │   │   │   ├── compiler_depend.make
│   │   │   │   ├── compiler_depend.ts
│   │   │   │   ├── DependInfo.cmake
│   │   │   │   └── progress.make
│   │   │   ├── cmake.check_cache
│   │   │   ├── CMakeConfigureLog.yaml
│   │   │   ├── CMakeDirectoryInformation.cmake
│   │   │   ├── CMakeRuleHashes.txt
│   │   │   ├── Makefile2
│   │   │   ├── Makefile.cmake
│   │   │   ├── pkgRedirects
│   │   │   ├── progress.marks
│   │   │   ├── TargetDirectories.txt
│   │   │   └── uninstall.dir
│   │   │       ├── build.make
│   │   │       ├── cmake_clean.cmake
│   │   │       ├── compiler_depend.make
│   │   │       ├── compiler_depend.ts
│   │   │       ├── DependInfo.cmake
│   │   │       └── progress.make
│   │   ├── cmake_install.cmake
│   │   ├── colcon_build.rc
│   │   ├── colcon_command_prefix_build.sh
│   │   ├── colcon_command_prefix_build.sh.env
│   │   ├── CTestConfiguration.ini
│   │   ├── CTestCustom.cmake
│   │   ├── CTestTestfile.cmake
│   │   ├── install_manifest.txt
│   │   └── Makefile
│   ├── car_hardware
│   │   ├── build
│   │   │   └── lib
│   │   │       └── car_hardware
│   │   │           ├── game_control_cli.py
│   │   │           ├── __init__.py
│   │   │           ├── servo_calibration_node.py
│   │   │           ├── stm32_driver_node.py
│   │   │           └── teleop_keyboard_node.py
│   │   ├── car_hardware.egg-info
│   │   │   ├── dependency_links.txt
│   │   │   ├── entry_points.txt
│   │   │   ├── PKG-INFO
│   │   │   ├── requires.txt
│   │   │   ├── SOURCES.txt
│   │   │   ├── top_level.txt
│   │   │   └── zip-safe
│   │   ├── colcon_build.rc
│   │   ├── colcon_command_prefix_setup_py.sh
│   │   ├── colcon_command_prefix_setup_py.sh.env
│   │   └── prefix_override
│   │       ├── __pycache__
│   │       └── sitecustomize.py
│   └── COLCON_IGNORE
├── codebase.txt
├── create_codebase.sh
├── .git
│   ├── branches
│   ├── COMMIT_EDITMSG
│   ├── config
│   ├── description
│   ├── FETCH_HEAD
│   ├── HEAD
│   ├── hooks
│   │   ├── applypatch-msg.sample
│   │   ├── commit-msg.sample
│   │   ├── fsmonitor-watchman.sample
│   │   ├── post-update.sample
│   │   ├── pre-applypatch.sample
│   │   ├── pre-commit.sample
│   │   ├── prepare-commit-msg.sample
│   │   ├── pre-push.sample
│   │   ├── pre-rebase.sample
│   │   ├── pre-receive.sample
│   │   └── update.sample
│   ├── index
│   ├── info
│   │   └── exclude
│   ├── logs
│   │   ├── HEAD
│   │   └── refs
│   │       ├── heads
│   │       │   └── main
│   │       └── remotes
│   │           └── origin
│   │               ├── HEAD
│   │               └── main
│   ├── objects
│   │   ├── 00
│   │   │   └── ea06740bb56b874a2b91579b1ab3ae77f31000
│   │   ├── 01
│   │   │   └── e21a0a6130615f19a2a7438065513da7257d62
│   │   ├── 04
│   │   │   └── 2e8962fffa2355c421ad1fed6a3cdafa4ab5df
│   │   ├── 05
│   │   │   ├── 93516dfd300216bc37ef160c0898fe744d6ce7
│   │   │   └── c23c79dbb59e62c72617f0e2f46bd6dc8ffe3c
│   │   ├── 06
│   │   │   ├── 494a0c5586948d014d2ed645aa85cd3015359c
│   │   │   └── 6d0e60fabf55c0766877d6e94c93df14c2e011
│   │   ├── 07
│   │   │   └── b22b52d30db6ccaabbf778a7808d39bb490781
│   │   ├── 0a
│   │   │   ├── 28d630906fca8da875aea77af34d9cbf42640b
│   │   │   └── 296f14b3d8f2cfcd8d0be0dd4b77c3d0fa4145
│   │   ├── 0c
│   │   │   └── 306c7e3315df485b684bb5a22bb9899f279ffa
│   │   ├── 0d
│   │   │   └── 1c7383382fc64a9fc729a161e7f1612fb60e71
│   │   ├── 0e
│   │   │   └── 1fe2075a854c87f029b506a3fd7a8fcfb50dbc
│   │   ├── 11
│   │   │   └── e6b5035082480dbeb46abcd08e4e2335558745
│   │   ├── 13
│   │   │   ├── 7d6a38bb95c11dfbfa633ece57c09ed8760caf
│   │   │   └── a75753c95f3c4293e3ed68fe12ea868af59233
│   │   ├── 14
│   │   │   └── 253db5d5378988b2b60257172c0f221b58d58c
│   │   ├── 16
│   │   │   └── 9ea2bc8e3238691c8dfcf6c72781400913e1ed
│   │   ├── 17
│   │   │   └── 7f42ab3b94e7a53c3e721d719a4e1ea897789e
│   │   ├── 19
│   │   │   ├── 8f59d7dab9f9ee602d589a3c01413a631b2cc1
│   │   │   ├── 9fc87ecb9efa6ab4ba0e75a95c68efab7d73ad
│   │   │   └── db1622f6b901b2f7c166e3795822d6522d5c27
│   │   ├── 1c
│   │   │   ├── 4d3c27fdf7aa7ca70a632a5f61ab9f11c51099
│   │   │   └── c408ce58ed765e5788111d31fc4ebf3a6e2577
│   │   ├── 1e
│   │   │   ├── 0de79fc8cd1452c63fa735c2c6c03cdcc8ba31
│   │   │   ├── 1df454d52249826b4eef68d24409304cb55f15
│   │   │   └── 72e3c11daa5bfe09fe697f4578cd2aece0801f
│   │   ├── 1f
│   │   │   ├── 50076bb7b844111c6f48cacf1eb101ea3b9a51
│   │   │   └── fdfe703ed41637c1b09cbecd7d41dc898c3835
│   │   ├── 20
│   │   │   └── c0eaed6f7848536694aa2b77a08fe9fa25849e
│   │   ├── 21
│   │   │   ├── 9f355ee069c4c354f9206ac2654c63f1b4fe4e
│   │   │   ├── c8888b40a76ada10450158e59bc70d662d3a1d
│   │   │   └── eb56933a649c09af4558791b6a3cebafe55c5c
│   │   ├── 22
│   │   │   └── 8fba3b2b7e1647c6a7a43715fab579f74ddfda
│   │   ├── 23
│   │   │   └── 4aaa5d461821994792d73547400d6e3cb6b10f
│   │   ├── 24
│   │   │   └── 8f4142698b844378cb5357eb6d0af1bbc42a0d
│   │   ├── 25
│   │   │   ├── 52cfa3c4d3b78bb618f1b697e9d229b73ca2eb
│   │   │   └── f0d316b87c2bd8511e7b0e44f6e75c69dc66da
│   │   ├── 26
│   │   │   └── 2e86c8e0c168f25a1bdd678257e820e8b98285
│   │   ├── 27
│   │   │   ├── ccd8f5e7a92b9183ec9ec3215f21afd9744496
│   │   │   └── ee1078ff077cc3a0fec75b7d023101a68164d1
│   │   ├── 28
│   │   │   └── 1338e48da3cdbca17efd5ca385e3f5e087c6dc
│   │   ├── 29
│   │   │   └── ea02eb44a1169299936b36944e22d4d18c58dc
│   │   ├── 2a
│   │   │   └── 1854c26d6be2fa1ed6fc436961fb7e2aaddcdb
│   │   ├── 2d
│   │   │   └── 8001a0c3e704b6e17103993c565e9a51749e5a
│   │   ├── 2e
│   │   │   └── 3720e6f2c53c62560099c4b378269eacfc05bd
│   │   ├── 2f
│   │   │   └── d184a231084d36e27ccb7fcdd9302368cabcc0
│   │   ├── 32
│   │   │   ├── 4a80c10474c81d1672bc59a68b0c8163fc75db
│   │   │   └── 6d068d2bb80d31b7461f9dd56526e885756c62
│   │   ├── 34
│   │   │   └── ebeb7f52cc6666f9a35ecc1e82e0c917c113c3
│   │   ├── 36
│   │   │   └── d147676f9c997146cef8ed424bc61fc43fa192
│   │   ├── 3b
│   │   │   ├── 8d19cf077342d7b72be04b304788aac9f4cf10
│   │   │   └── dd2d9f454d36228d10aeb6308b4b2aceac2cb9
│   │   ├── 3c
│   │   │   ├── 1e3c41540f063fe5c8b9d624c6bf4dc97e8b94
│   │   │   ├── 7446031de6101afbea6594500c543ee15fe468
│   │   │   ├── 8924da62bffa38fc62ee29eb67cc810e06dc6b
│   │   │   └── abef1e419a23255891ddd9103cfc6731416d42
│   │   ├── 3f
│   │   │   └── ce5d0494875cbdc400c285b282f3b7a6e1d16c
│   │   ├── 4d
│   │   │   └── ca498c51529e48770924f46889a6a3bfe48a9d
│   │   ├── 4e
│   │   │   ├── 2e6a4fb47dde9e23f4939f67022d551af2cf58
│   │   │   └── dbce0a341de448dfdb01b728102d6f830a7ebe
│   │   ├── 4f
│   │   │   └── 70c98dae616bb75891437c6ffafaa654a28140
│   │   ├── 50
│   │   │   ├── b54a195f98e7fb43008eb378427489c06e8883
│   │   │   └── c6bea66e7fb4648302660b58269b729dc1741a
│   │   ├── 52
│   │   │   └── 83f9ab9842dda6539ef3232621d75cda2cb8a3
│   │   ├── 53
│   │   │   └── 21dc97af69bb20afbc85c2016449433fd2a44d
│   │   ├── 57
│   │   │   └── ae3e78994d64f71a88b6473b1fef5cbe96de6f
│   │   ├── 5a
│   │   │   └── 1b1bdc72766fda41dff8141db633b600426300
│   │   ├── 5d
│   │   │   └── 3a809484ed37f8ce5bf1532b8aa3ae255590ab
│   │   ├── 5e
│   │   │   ├── 31dbb74535c49fd05d56d73dcd2f73a6168616
│   │   │   └── 8d7144b63759d00154c758e57d54bc32326d37
│   │   ├── 5f
│   │   │   └── 0f478ef10e8fda0c832751983c8278a08b781c
│   │   ├── 60
│   │   │   └── b903dec4efe338e8f763b7d4bb6ca33dc01a56
│   │   ├── 61
│   │   │   └── f9c76696068d47acbbcba77a6ce4375c68872f
│   │   ├── 62
│   │   │   └── 9eea032be0638e04bad9de5a56d463c95265b3
│   │   ├── 63
│   │   │   └── 54f2fdb971b6a6c9dda0b0e961efee9f6daaac
│   │   ├── 64
│   │   │   ├── 3b6bd8c44939ac26914aba9ffac8b1d2f80192
│   │   │   └── 51371ea5c508fd554618f3a26598821267d917
│   │   ├── 65
│   │   │   └── 85f9d98f954e9c0beb3880fcde25ed37e2c729
│   │   ├── 66
│   │   │   └── fb1949f25e52fa6b0ee59fb8a5fdd31f402343
│   │   ├── 67
│   │   │   └── c46885e80b68c07b396ad0685ff745c73743c3
│   │   ├── 69
│   │   │   ├── 9928e2ec513ccf11c2937014f424488f135f7f
│   │   │   └── a833c1bd50cae1955560914798565824d80a44
│   │   ├── 6a
│   │   │   └── 10686465df5beb726136621f4b5a22a190a377
│   │   ├── 6b
│   │   │   ├── 00b67cd675d3e376d68b1b4ac85a7029551647
│   │   │   └── 0d148ca8e221d8e7bb8328cb1b62b823cc6ae5
│   │   ├── 6c
│   │   │   └── c14e4e1e2e15e3da18232b7037729d4bff88f7
│   │   ├── 6e
│   │   │   └── 233114c646d412a823966e67965d7503aa384f
│   │   ├── 6f
│   │   │   └── c928825a70d274e13da6e04cdc5d2a9e8ec0cc
│   │   ├── 71
│   │   │   └── 22e489e3cf80c0a2c859b58daea26632388bb9
│   │   ├── 73
│   │   │   ├── 7fcab0d498236648f8fac04381f3d87b0cc622
│   │   │   └── adbe6150265c0cf95dc62ff55028c8abcfabb2
│   │   ├── 74
│   │   │   └── 4ed389a7a9055e2246f63ae18bc190dd53a0c2
│   │   ├── 75
│   │   │   ├── 260eaad7b1b5f7745954f043207ae0421662ea
│   │   │   └── 5288cb6003ac7a322fe4577ed98d4bbb919acf
│   │   ├── 77
│   │   │   ├── cafb712fc76d1a530dcef5f1c31dbd3caa55cc
│   │   │   └── e0b0551fd3535efc94f5eba50699782910ef1b
│   │   ├── 78
│   │   │   ├── 53735af580fae97fd4b55d3f5e9b6aa1dda353
│   │   │   ├── 6ca239ef6f5533c4f7ab6374d8402c1d724533
│   │   │   └── 75263abffa306b85b716cc267a2ecb9a969e5f
│   │   ├── 7a
│   │   │   └── e484f631eedf22456d32080989969731dccb78
│   │   ├── 7c
│   │   │   ├── 45e68487ca246057074912a0ca7888c383b6a2
│   │   │   └── 8c2601d846048e7e4b24d20c82a43b0b292aff
│   │   ├── 7d
│   │   │   ├── 11704c363db43f3b7a8ec41b16b4f1fc56b8eb
│   │   │   └── 977585be6549f19f8c33c955ef976440b1b178
│   │   ├── 7e
│   │   │   └── 273bd7f91e22f45185095841a3991fde99555d
│   │   ├── 85
│   │   │   ├── 7bfe84873199b5e5bc4298961c3e0d954270c5
│   │   │   └── b9ac5f2ddc400fdacb63bba48d2fb2e6a636d8
│   │   ├── 86
│   │   │   └── d9faaba8bde2700ffd55e34fc0efcd78661a5c
│   │   ├── 87
│   │   │   └── 3711199b5a7553691878c1e50c46b3cab41a7d
│   │   ├── 88
│   │   │   └── dfbf71214de3172f4d41d0af229f8582a9de55
│   │   ├── 8b
│   │   │   └── ee9f9d300c55a8a3c5aa8bb18a78e167ba10d7
│   │   ├── 8c
│   │   │   └── 5035a6af9a7e2786cb469fb38ee95ea70f66c2
│   │   ├── 8f
│   │   │   ├── 7b2a804857a51a8926747ae9fbddfe6c97d5a4
│   │   │   └── 8195387c4904fabb126a4083be4071fdea52fc
│   │   ├── 90
│   │   │   └── 2c5dde7b954a26dfc1e9777e59b47b22f7ab5b
│   │   ├── 91
│   │   │   ├── 2219ca8bc301965f8d9ace9a11b81effc05ada
│   │   │   └── 96a00abb961cadb84694471a0f7544e88b9955
│   │   ├── 92
│   │   │   └── dddee4029292644283e0b03c92fd1451494e35
│   │   ├── 95
│   │   │   └── 5e94740c60da3582bd988d5b02f3c7b604a011
│   │   ├── 96
│   │   │   ├── 2ef7913f0f5c72735e52ce91870aee4b0cf8c4
│   │   │   └── b8ab2f37626358c4c877be3f2bd6cf904cfa62
│   │   ├── 97
│   │   │   ├── a062b74fa007349f97f333a18ef8cfef03883d
│   │   │   ├── a39196e84db97954341162a6d2e7f771d938c0
│   │   │   └── cad041615d006744e8064e3a9ac3f9bcda07dc
│   │   ├── 99
│   │   │   ├── 367b3dd9fe87ac0a1e2fd9c78d0b0f348de18e
│   │   │   └── f13cc9a1801f2be598d3f127515bb4411018c6
│   │   ├── 9b
│   │   │   └── 36083a645a2e24ecc7e56b5d67673b8d79d32a
│   │   ├── 9c
│   │   │   └── 92f56727d1aff20d4f3bdfac97bac31da2c39e
│   │   ├── 9d
│   │   │   ├── 448c475a1c43f82bfdc539b3f8d82b3fe8a6f5
│   │   │   └── d13675f6aff8812814e1c3a16d4fd5c161ed83
│   │   ├── 9e
│   │   │   └── 3691ecebc8d031257525f1d6b5cbdeb35fea53
│   │   ├── 9f
│   │   │   ├── 467c605a76b47f64edebcd539ae1d57af259cf
│   │   │   └── 5d6f0e156b18ffed851ef93dcf9c7142a4498d
│   │   ├── a0
│   │   │   └── 445564c88e8dbe624d9a91ab04eb32dd0eb68f
│   │   ├── a1
│   │   │   └── 4aad77c522ed6d1484685ccc1ac3ec38653216
│   │   ├── a3
│   │   │   ├── 3ba79801135a1b80760603278883030aad2582
│   │   │   └── b00b0b02b23663fc8c4352e40dfd3a324d1d01
│   │   ├── a4
│   │   │   ├── 16dad58bacf1ecfaa659f02ecdc1b41725b1aa
│   │   │   └── 66ef8513a01bb9e26de4f49c5b2f7615f1ce2e
│   │   ├── a7
│   │   │   └── 1b5c2e08d7df552608c5da4d9a519d10a54268
│   │   ├── a9
│   │   │   ├── 0d7814dddf15423b0026fcf9025e66a57b898d
│   │   │   ├── 2033dba41ce9d54427ef7c63ce8c6d689d1e13
│   │   │   └── 7428b8d8f9e0e5c7279bc6405c3accf30002ad
│   │   ├── ab
│   │   │   └── 97494858835b42812bc20568da26c2d6cf5b5d
│   │   ├── ac
│   │   │   ├── 74d1e6bd19665f5f3e21a59f35b25df4a4ccad
│   │   │   └── a4541a698c2c127851e955efb7953b4f30aa3b
│   │   ├── b1
│   │   │   └── 126c532d8316d0fadb088c8a2248d0f20a8190
│   │   ├── b2
│   │   │   └── 34a3840f4c5bd38f043638c8622b8f240e1185
│   │   ├── b4
│   │   │   ├── 8769ba8602a0dd38794b29bebf26c2b43fc0b7
│   │   │   └── aba2c20e6bfade671bc3a644308ce4ce2a2fba
│   │   ├── b7
│   │   │   ├── 0a0742f6fbaa28c6e9c08622ba1766c156e136
│   │   │   └── e43c0e2aa6a5f7e8081a1fb392a42372c88567
│   │   ├── b9
│   │   │   └── 384377327ed9df4a5d00138e273b822bb8f32c
│   │   ├── bb
│   │   │   ├── 0e70231063ebedc94106a9b7d77aa3bb5af904
│   │   │   ├── 893edf573d8e586ff40d633a94e320c8f573ae
│   │   │   └── e739fba3a931e1226a604d3d928a11ba05ba59
│   │   ├── be
│   │   │   ├── 49498be7abea025140c4664f57ae8b50917f5b
│   │   │   ├── 6e63a1c4618974c78368681ff2c74ab33ff284
│   │   │   └── d9b4cfcd920abcc7a5478433dceb613ecbc57e
│   │   ├── bf
│   │   │   ├── 381d666cfa008e851b16addbabebbaeedf0f3a
│   │   │   └── 60e2a2b9f62d882970b359e48104802e0e4fcb
│   │   ├── c2
│   │   │   └── 8cee39d4ba28a9f11bf6f2fe72970519f0e9f4
│   │   ├── c3
│   │   │   ├── 4cc62e60a73e0363cc4fbb40e3d62d8af6d97f
│   │   │   └── 7cdb3dfdf3edc255f237fa129e42f9eecdc885
│   │   ├── c4
│   │   │   └── ffd19fa45d2ea741a5914a157a424a99c61dca
│   │   ├── c5
│   │   │   └── 6c4f0def3b37c8a6aaf79b3099acb6c32a7f20
│   │   ├── c7
│   │   │   └── b484412475e973b2cfb7a124f45beb8117f04f
│   │   ├── cd
│   │   │   ├── 1d7c6b5f5df897687172eb4e9aeacaeed3abc3
│   │   │   └── af34fd9f6e32e4f42553aeba9ef8cd026b2f0c
│   │   ├── d1
│   │   │   └── 169769e70d3b986c268c6fb34d200f55befd05
│   │   ├── d2
│   │   │   └── 4d04598dec8d4a0e2de920f6a0669e53d00f35
│   │   ├── d3
│   │   │   ├── 31f1e905dd7a8196e6463eea1714c715434225
│   │   │   └── 3f3ba8fd8e8fd11bb268f0e7408065cd09bef0
│   │   ├── d4
│   │   │   └── 2236be5b983cb56f9dc7cd4b4487cf9c3df6b2
│   │   ├── d9
│   │   │   └── 8ae375cc984cca7af1aab972f159cc1214a4bc
│   │   ├── dc
│   │   │   ├── 01e26cd66897db5b2d3b32fe156c23f29b7143
│   │   │   ├── 0cc9962e808dc31de91fe2b3b1d1a57dea448c
│   │   │   └── c8bd3af33039fe0e9e7013ace5190359e1b324
│   │   ├── de
│   │   │   └── 6efb7b8388e051911bbf60597d26f41857bcb1
│   │   ├── e0
│   │   │   ├── 1e72a695622bf298e79ad1cb27ba41eb55fa73
│   │   │   ├── 44a6f0bf3446b62dcafcca855b9bdd58db6d22
│   │   │   └── aa15be21278f97456d76e5a663ed37cf30969e
│   │   ├── e1
│   │   │   ├── 0029ef74a689b3d57c1e143db99d6bd7a2e519
│   │   │   ├── 60d83e4484a90870d9dff75b99ea3d59d4c733
│   │   │   └── d424048a11cfa453715055386d5bd0cfb75efd
│   │   ├── e6
│   │   │   └── 9de29bb2d1d6434b8b29ae775ad8c2e48c5391
│   │   ├── e7
│   │   │   ├── 9b71f39d2a03fca26f06f02f248bd66255ad89
│   │   │   └── e1cfa443753b92b0e51b3be2074a03762ac742
│   │   ├── e9
│   │   │   ├── 4a642acbcaa6bc964a4c203dcee2e11b7f6f91
│   │   │   ├── c045470736d7ce5d06270060f665cb172209d9
│   │   │   └── fbcd9ca9166d03e076d5d27e63ad269bd41dad
│   │   ├── ea
│   │   │   ├── 2445bfa454b428a56776ade7862d13d8044161
│   │   │   └── 6408b40c3d3f5e9d199a821d4e2238a4fceadd
│   │   ├── eb
│   │   │   ├── 315a106ffbecf2e7e5541e750588e6d9998585
│   │   │   ├── 340870b0d4a14b2e05be7f7c42e9e8635579c7
│   │   │   └── 4824d0bc525e0b016a6c3447fa4d76742eddab
│   │   ├── ec
│   │   │   └── 1c72aed78be7a0ac6c35d8bef6db3f1dbce47a
│   │   ├── ed
│   │   │   └── bd5e8e37682722272c19a1fdaebf4d93e56d55
│   │   ├── ee
│   │   │   ├── 107a79f1d6563c84f1936aeed156f4bcaf9706
│   │   │   └── 6053b97a9163bc23f52ea9db0f2fd0cde4a29b
│   │   ├── ef
│   │   │   └── 2fc59bdeb70c39788997f3281121ef017de965
│   │   ├── f0
│   │   │   └── 94633808d51fa5f2ad823a5294ea2c7fff0779
│   │   ├── f2
│   │   │   ├── 2a8162bca31a1a3ffb909b23bfbeb088996782
│   │   │   └── a04a69b98f82e0db168fd2df57302e92abb2ff
│   │   ├── f4
│   │   │   └── 225db7828742b5e7d12aedb8658df60af399bf
│   │   ├── f5
│   │   │   ├── 2ba7be902ad82d9b0432eceb4e6338e15e33c0
│   │   │   └── f869d3a17ee86142674c07e1abf1276fa1a1f3
│   │   ├── f7
│   │   │   └── f8c3cbae5bd1d5eb64e909e95ba6e1a71f2db2
│   │   ├── f9
│   │   │   └── 57c1c9d85b54b93137524780ab3d3bc3364819
│   │   ├── fa
│   │   │   ├── 3d1c2df5474d8b276d15b279915d31104b1bf6
│   │   │   └── e6baf6ab8cf9b62de8285eeea7192addc4dfa0
│   │   ├── fb
│   │   │   └── 7ff4179e651276b8fd84e2d453fa2b3d25a287
│   │   ├── fc
│   │   │   └── 7d7f5fb5f20af972f8f0a8e5fe73d40a173e19
│   │   ├── fd
│   │   │   └── e64aef4bfea533dbda28e4da07218b9734ddf7
│   │   ├── fe
│   │   │   └── 7166a80b26c83df8887b9fa374421af9b10eb9
│   │   ├── ff
│   │   │   └── 7f48d3c784565b4fd68cd4ca104782e8698a98
│   │   ├── info
│   │   └── pack
│   ├── ORIG_HEAD
│   ├── packed-refs
│   └── refs
│       ├── heads
│       │   └── main
│       ├── remotes
│       │   └── origin
│       │       ├── HEAD
│       │       └── main
│       └── tags
├── .gitignore
├── install
│   ├── car_autonomy
│   │   ├── lib
│   │   │   ├── car_autonomy
│   │   │   │   ├── lane_detection
│   │   │   │   └── lane_follower
│   │   │   └── python3.6
│   │   │       └── site-packages
│   │   │           ├── car_autonomy
│   │   │           │   ├── __init__.py
│   │   │           │   ├── lane_detection.py
│   │   │           │   ├── lane_follower.py
│   │   │           │   └── __pycache__
│   │   │           └── car_autonomy-0.0.0-py3.6.egg-info
│   │   │               ├── dependency_links.txt
│   │   │               ├── entry_points.txt
│   │   │               ├── PKG-INFO
│   │   │               ├── requires.txt
│   │   │               ├── SOURCES.txt
│   │   │               ├── top_level.txt
│   │   │               └── zip-safe
│   │   └── share
│   │       ├── ament_index
│   │       │   └── resource_index
│   │       │       └── packages
│   │       │           └── car_autonomy
│   │       ├── car_autonomy
│   │       │   ├── hook
│   │       │   │   ├── ament_prefix_path.dsv
│   │       │   │   ├── ament_prefix_path.ps1
│   │       │   │   ├── ament_prefix_path.sh
│   │       │   │   ├── pythonpath.dsv
│   │       │   │   ├── pythonpath.ps1
│   │       │   │   └── pythonpath.sh
│   │       │   ├── launch
│   │       │   │   ├── autonomy.launch.py
│   │       │   │   └── __pycache__
│   │       │   ├── package.bash
│   │       │   ├── package.dsv
│   │       │   ├── package.ps1
│   │       │   ├── package.sh
│   │       │   ├── package.xml
│   │       │   └── package.zsh
│   │       └── colcon-core
│   │           └── packages
│   │               └── car_autonomy
│   ├── car_bringup
│   │   └── share
│   │       ├── ament_index
│   │       │   └── resource_index
│   │       │       ├── package_run_dependencies
│   │       │       │   └── car_bringup
│   │       │       ├── packages
│   │       │       │   └── car_bringup
│   │       │       └── parent_prefix_path
│   │       │           └── car_bringup
│   │       ├── car_bringup
│   │       │   ├── cmake
│   │       │   │   ├── car_bringupConfig.cmake
│   │       │   │   └── car_bringupConfig-version.cmake
│   │       │   ├── config
│   │       │   ├── environment
│   │       │   │   ├── ament_prefix_path.dsv
│   │       │   │   ├── ament_prefix_path.sh
│   │       │   │   ├── path.dsv
│   │       │   │   └── path.sh
│   │       │   ├── hook
│   │       │   │   ├── cmake_prefix_path.dsv
│   │       │   │   ├── cmake_prefix_path.ps1
│   │       │   │   └── cmake_prefix_path.sh
│   │       │   ├── launch
│   │       │   │   ├── __pycache__
│   │       │   │   ├── sensors.launch.py
│   │       │   │   └── teleop.launch.py
│   │       │   ├── local_setup.bash
│   │       │   ├── local_setup.dsv
│   │       │   ├── local_setup.sh
│   │       │   ├── local_setup.zsh
│   │       │   ├── package.bash
│   │       │   ├── package.dsv
│   │       │   ├── package.ps1
│   │       │   ├── package.sh
│   │       │   ├── package.xml
│   │       │   └── package.zsh
│   │       └── colcon-core
│   │           └── packages
│   │               └── car_bringup
│   ├── car_hardware
│   │   ├── lib
│   │   │   ├── car_hardware
│   │   │   │   ├── game_control_cli
│   │   │   │   ├── servo_calibration_node
│   │   │   │   ├── stm32_driver
│   │   │   │   └── teleop_keyboard
│   │   │   └── python3.6
│   │   │       └── site-packages
│   │   │           ├── car_hardware
│   │   │           │   ├── game_control_cli.py
│   │   │           │   ├── __init__.py
│   │   │           │   ├── __pycache__
│   │   │           │   ├── servo_calibration_node.py
│   │   │           │   ├── stm32_driver_node.py
│   │   │           │   └── teleop_keyboard_node.py
│   │   │           └── car_hardware-0.0.1-py3.6.egg-info
│   │   │               ├── dependency_links.txt
│   │   │               ├── entry_points.txt
│   │   │               ├── PKG-INFO
│   │   │               ├── requires.txt
│   │   │               ├── SOURCES.txt
│   │   │               ├── top_level.txt
│   │   │               └── zip-safe
│   │   └── share
│   │       ├── ament_index
│   │       │   └── resource_index
│   │       │       └── packages
│   │       │           └── car_hardware
│   │       ├── car_hardware
│   │       │   ├── hook
│   │       │   │   ├── ament_prefix_path.dsv
│   │       │   │   ├── ament_prefix_path.ps1
│   │       │   │   ├── ament_prefix_path.sh
│   │       │   │   ├── pythonpath.dsv
│   │       │   │   ├── pythonpath.ps1
│   │       │   │   └── pythonpath.sh
│   │       │   ├── package.bash
│   │       │   ├── package.dsv
│   │       │   ├── package.ps1
│   │       │   ├── package.sh
│   │       │   ├── package.xml
│   │       │   └── package.zsh
│   │       └── colcon-core
│   │           └── packages
│   │               └── car_hardware
│   ├── COLCON_IGNORE
│   ├── .colcon_install_layout
│   ├── local_setup.bash
│   ├── local_setup.ps1
│   ├── local_setup.sh
│   ├── _local_setup_util_ps1.py
│   ├── _local_setup_util_sh.py
│   ├── local_setup.zsh
│   ├── setup.bash
│   ├── setup.ps1
│   ├── setup.sh
│   └── setup.zsh
└── src
    ├── car_autonomy
    │   ├── car_autonomy
    │   │   ├── __init__.py
    │   │   ├── lane_detection.py
    │   │   └── lane_follower.py
    │   ├── launch
    │   │   └── autonomy.launch.py
    │   ├── package.xml
    │   ├── resource
    │   │   └── car_autonomy
    │   ├── setup.cfg
    │   ├── setup.py
    │   └── test
    │       ├── test_copyright.py
    │       ├── test_flake8.py
    │       └── test_pep257.py
    ├── car_bringup
    │   ├── CMakeLists.txt
    │   ├── config
    │   ├── launch
    │   │   ├── sensors.launch.py
    │   │   └── teleop.launch.py
    │   └── package.xml
    └── car_hardware
        ├── car_hardware
        │   ├── game_control_cli.py
        │   ├── __init__.py
        │   ├── __pycache__
        │   ├── servo_calibration_node.py
        │   ├── stm32_driver_node.py
        │   └── teleop_keyboard_node.py
        ├── package.xml
        ├── resource
        │   └── car_hardware
        ├── setup.cfg
        ├── setup.py
        └── test
            ├── test_copyright.py
            ├── test_flake8.py
            └── test_pep257.py

269 directories, 462 files

==========================================

--- File: ./src/car_autonomy/resource/car_autonomy ---

--- File: ./src/car_autonomy/launch/autonomy.launch.py ---
from launch import LaunchDescription
from launch_ros.actions import Node
from launch.actions import IncludeLaunchDescription
from launch.launch_description_sources import PythonLaunchDescriptionSource
from ament_index_python.packages import get_package_share_directory
import os

def generate_launch_description():
    
    # 1. Include your EXISTING driver from car_bringup
    # This ensures we use the correct ports and settings you already have
    bringup_dir = get_package_share_directory('car_bringup')
    sensors_launch = IncludeLaunchDescription(
        PythonLaunchDescriptionSource(os.path.join(bringup_dir, 'launch', 'sensors.launch.py')),
        launch_arguments={'serial_port': '/dev/ttyTHS1'}.items()
    )

    return LaunchDescription([
        # Start the Hardware
        sensors_launch,

        # Start Lane Detection
        Node(
            package='car_autonomy',
            executable='lane_detection',
            name='lane_detector',
            output='screen',
            parameters=[{'record': True, 't_section_turn': 'left'}]
        ),

        # Start Lane Follower (Controller)
        Node(
            package='car_autonomy',
            executable='lane_follower',
            name='lane_follower',
            output='screen',
            parameters=[{'max_speed_ms': 1.0}] # Start slow!
        )
    ])

--- File: ./src/car_autonomy/package.xml ---
<?xml version="1.0"?>
<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
<package format="3">
  <name>car_autonomy</name>
  <version>0.0.0</version>
  <description>TODO: Package description</description>
  <maintainer email="phumint1969@gmail.com">root</maintainer>
  <license>TODO: License declaration</license>

  <depend>rclpy</depend>
  <depend>std_msgs</depend>
  <depend>geometry_msgs</depend>
  <depend>sensor_msgs</depend>

  <test_depend>ament_copyright</test_depend>
  <test_depend>ament_flake8</test_depend>
  <test_depend>ament_pep257</test_depend>
  <test_depend>python3-pytest</test_depend>

  <export>
    <build_type>ament_python</build_type>
  </export>
</package>

--- File: ./src/car_autonomy/car_autonomy/lane_follower.py ---
import rclpy
import math
from rclpy.node import Node
from std_msgs.msg import Float32
from geometry_msgs.msg import Twist

class PID:
    def __init__(self, Kp, Ki, Kd, limits=(-1.0, 1.0)):
        self.Kp = Kp
        self.Ki = Ki
        self.Kd = Kd
        self.min_out, self.max_out = limits
        self.integral = 0.0
        self.prev_error = 0.0

    def update(self, error):
        self.integral += error
        # Anti-windup for integral
        self.integral = max(-10.0, min(10.0, self.integral))
        
        derivative = error - self.prev_error
        self.prev_error = error
        
        output = (
            self.Kp * error +
            self.Ki * self.integral +
            self.Kd * derivative
        )
        return max(self.min_out, min(self.max_out, output))

class ControllerNode(Node):
    def __init__(self):
        super().__init__('lane_controller')

        self.declare_parameter('max_speed', 0.3)
        self.max_speed = self.get_parameter('max_speed').value

        self.offset = 0.0
        self.heading = 0.0
        self.prev_steer = 0.0

        self.create_subscription(Float32, 'lane_offset', self.offset_cb, 10)
        self.create_subscription(Float32, 'lane_heading', self.heading_cb, 10)
        self.pub_cmd = self.create_publisher(Twist, 'cmd_vel', 10)

        # UPDATED PID: Reduced gains to prevent twitching
        # We output directly to -1.0 to 1.0 range now
        self.pid = PID(Kp=6.0, Ki=0.0, Kd=0.1, limits=(-1.0, 1.0))
        
        self.timer = self.create_timer(0.03, self.control_loop)

    def offset_cb(self, msg): self.offset = msg.data
    def heading_cb(self, msg): self.heading = msg.data

    def control_loop(self):
        msg = Twist()

        # --- DISABLED T-SECTION OVERRIDE ---
        # This was causing the robot to lock up at 1.0 turn / 0.15 speed
        # if abs(self.heading) > 0.6:
        #     steer = math.copysign(1.0, self.heading)
        #     msg.linear.x = 0.15
        #     msg.angular.z = steer
        #     self.pub_cmd.publish(msg)
        #     return

        # --- NORMAL LANE FOLLOWING ---
        
        # 1. Calculate Weighted Error
        # Reduce these weights if the car oscillates too much
        # Assuming offset is roughly -1.0 to 1.0 range? 
        # If offset is pixels (e.g. 200), these weights are WAY too high.
        combined_error = (1.0 * self.offset) + (0.5 * self.heading)
        
        # 2. Compute PID Output (-1.0 to 1.0)
        # We invert the PID output because usually:
        # Positive Error (Line is Left) -> Requires Positive Turn (Left)
        # But previous code had -self.pid. Check this direction physically!
        steer_cmd = -self.pid.update(combined_error)

        # 3. Smooth steering (Low Pass Filter)
        # Helps prevent servo jitter
        steer_cmd = 0.7 * self.prev_steer + 0.3 * steer_cmd
        self.prev_steer = steer_cmd

        # 4. Dynamic Speed Adjustment
        # Slow down when turning sharply
        speed = self.max_speed * (1.0 - min(abs(steer_cmd), 0.8) * 0.5)
        speed = max(0.05, speed) # Ensure min speed isn't 0

        msg.linear.x = float(speed)
        msg.angular.z = float(steer_cmd)

        self.pub_cmd.publish(msg)

def main(args=None):
    rclpy.init(args=args)
    node = ControllerNode()
    try:
        rclpy.spin(node)
    finally:
        node.pub_cmd.publish(Twist()) # Stop on exit
        node.destroy_node()
        rclpy.shutdown()
--- File: ./src/car_autonomy/car_autonomy/__init__.py ---

--- File: ./src/car_autonomy/car_autonomy/lane_detection.py ---
import rclpy
from rclpy.node import Node
from std_msgs.msg import Float32

import cv2
import numpy as np
import threading

class LaneDetectionNode(Node):
    """
    Script 2 (Minimal):
    - Classical CV lane detection
    - Sliding window + polynomial curvature
    - Publishes lane offset and heading
    - NO FSM, NO cv_bridge, NO ROS image topics
    """

    def __init__(self):
        super().__init__('lane_detection_node')

        # Publishers (unchanged interface)
        self.pub_offset = self.create_publisher(Float32, 'lane_offset', 10)
        self.pub_heading = self.create_publisher(Float32, 'lane_heading', 10)

        # Camera
        self.cap = cv2.VideoCapture(0)
        if not self.cap.isOpened():
            self.get_logger().error('Camera not opened')

        self.latest_frame = None
        self.lock = threading.Lock()

        # Background capture thread
        threading.Thread(target=self._capture_frames, daemon=True).start()

        # Timer (20 Hz)
        self.timer = self.create_timer(0.05, self.timer_callback)

    # --------------------------------------------------
    def _capture_frames(self):
        while True:
            if not self.cap.isOpened():
                continue

            ret, frame = self.cap.read()
            if not ret:
                continue  # <-- VERY IMPORTANT on Jetson

            frame = cv2.resize(frame, (640, 480))
            with self.lock:
                self.latest_frame = frame


    # --------------------------------------------------
    def detect_lane(self, frame):
        height, width = frame.shape[:2]

        # --- ROI ---
        roi = frame[int(height * 0.6):height, :]

        # --- Perspective transform ---
        pts1 = np.float32([
            [0, roi.shape[0]],
            [width, roi.shape[0]],
            [width, 0],
            [0, 0]
        ])
        pts2 = np.float32([
            [0, height],
            [width, height],
            [width, 0],
            [0, 0]
        ])
        M = cv2.getPerspectiveTransform(pts1, pts2)
        Minv = cv2.getPerspectiveTransform(pts2, pts1)
        warped = cv2.warpPerspective(roi, M, (width, height))

        # --- Color mask (white + yellow) ---
        hsv = cv2.cvtColor(warped, cv2.COLOR_BGR2HSV)
        white_mask = cv2.inRange(hsv, (106, 0, 219), (144, 255, 255))
        yellow_mask = cv2.inRange(hsv, (79, 43, 207), (72, 155, 233))
        mask = cv2.bitwise_or(white_mask, yellow_mask)

        # --- Sliding window ---
        lx, rx = self.sliding_window(mask)

        if len(lx) < 10 or len(rx) < 10:
            return 0.0, 0.0, frame

        # --- Polynomial fit (curvature) ---
        # Get y coordinates from mask
        nonzero = mask.nonzero()
        nonzeroy = np.array(nonzero[0])
        nonzerox = np.array(nonzero[1])

        left_inds  = np.isin(nonzerox, lx)
        right_inds = np.isin(nonzerox, rx)

        leftx  = nonzerox[left_inds]
        lefty  = nonzeroy[left_inds]
        rightx = nonzerox[right_inds]
        righty = nonzeroy[right_inds]

        if len(leftx) < 50 or len(rightx) < 50:
            return 0.0, 0.0, frame

        left_fit  = np.polyfit(lefty, leftx, 2)
        right_fit = np.polyfit(righty, rightx, 2)


        center_fit = (left_fit + right_fit) / 2.0

        # Heading from curvature derivative
        y_eval = height * 0.9
        dx_dy = 2 * center_fit[0] * y_eval + center_fit[1]
        heading = float(np.arctan(dx_dy))

        # Offset
        lane_center = (np.mean(lx) + np.mean(rx)) / 2
        offset = (lane_center - width / 2) / (width / 2)

        # --- Visualization ---
        plot_y = np.linspace(0, height - 1, height)
        left_x = left_fit[0] * plot_y**2 + left_fit[1] * plot_y + left_fit[2]
        right_x = right_fit[0] * plot_y**2 + right_fit[1] * plot_y + right_fit[2]

        lane_vis = warped.copy()
        for y, lx_p, rx_p in zip(plot_y.astype(int), left_x.astype(int), right_x.astype(int)):
            if 0 <= lx_p < width and 0 <= rx_p < width:
                cv2.circle(lane_vis, (lx_p, y), 1, (255, 0, 0), -1)
                cv2.circle(lane_vis, (rx_p, y), 1, (0, 0, 255), -1)

        lane_area = np.zeros_like(lane_vis)
        pts = np.vstack((np.transpose(np.vstack([left_x, plot_y])),
                          np.flipud(np.transpose(np.vstack([right_x, plot_y])))))
        cv2.fillPoly(lane_area, [pts.astype(np.int32)], (0, 255, 0))

        unwarped_lane = cv2.warpPerspective(lane_area, Minv, (width, roi.shape[0]))
        frame[int(height * 0.6):height, :] = cv2.addWeighted(
            frame[int(height * 0.6):height, :], 1.0, unwarped_lane, 0.3, 0)

        cv2.putText(frame, f'Offset: {offset:.2f}', (10, 30),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 255, 255), 2)
        cv2.putText(frame, f'Heading: {heading:.2f} rad', (10, 60),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 255, 255), 2)

        return float(offset), float(heading), frame

    # --------------------------------------------------
    def sliding_window(self, mask):
        histogram = np.sum(mask[mask.shape[0] // 2:, :], axis=0)
        midpoint = histogram.shape[0] // 2
        left_base = np.argmax(histogram[:midpoint])
        right_base = np.argmax(histogram[midpoint:]) + midpoint

        n_windows = 12
        window_height = mask.shape[0] // n_windows
        nonzero = mask.nonzero()
        nonzeroy = np.array(nonzero[0])
        nonzerox = np.array(nonzero[1])

        margin = 50
        minpix = 50
        lx, rx = [], []
        left_current, right_current = left_base, right_base

        for window in range(n_windows):
            win_y_low = mask.shape[0] - (window + 1) * window_height
            win_y_high = mask.shape[0] - window * window_height

            good_left = ((nonzeroy >= win_y_low) & (nonzeroy < win_y_high) &
                         (nonzerox >= left_current - margin) & (nonzerox < left_current + margin))
            good_right = ((nonzeroy >= win_y_low) & (nonzeroy < win_y_high) &
                          (nonzerox >= right_current - margin) & (nonzerox < right_current + margin))

            if np.sum(good_left) > minpix:
                left_current = int(np.mean(nonzerox[good_left]))
            if np.sum(good_right) > minpix:
                right_current = int(np.mean(nonzerox[good_right]))

            lx.extend(nonzerox[good_left])
            rx.extend(nonzerox[good_right])

        return np.array(lx), np.array(rx)

    # --------------------------------------------------
    def timer_callback(self):
        with self.lock:
            frame = self.latest_frame

        if frame is None:
            return

        offset, heading, visual = self.detect_lane(frame)

        msg_o = Float32()
        msg_o.data = offset
        self.pub_offset.publish(msg_o)

        msg_h = Float32()
        msg_h.data = heading
        self.pub_heading.publish(msg_h)

    # --------------------------------------------------
    def destroy_node(self):
        if self.cap.isOpened():
            self.cap.release()
        super().destroy_node()


def main(args=None):
    rclpy.init(args=args)
    node = LaneDetectionNode()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()

--- File: ./src/car_autonomy/setup.py ---
from setuptools import setup
import os
from glob import glob

package_name = 'car_autonomy'

setup(
    name=package_name,
    version='0.0.0',
    packages=[package_name],
    data_files=[
        ('share/ament_index/resource_index/packages',
            ['resource/' + package_name]),
        ('share/' + package_name, ['package.xml']),
        
        # --- ADD THIS BLOCK HERE ---
        # This tells ROS: "Take everything in the 'launch' folder 
        # and put it where ros2 launch can find it."
        (os.path.join('share', package_name, 'launch'), glob('launch/*.launch.py')),
        # ---------------------------
    ],
    install_requires=['setuptools'],
    zip_safe=True,
    maintainer='root',
    maintainer_email='root@todo.todo',
    description='Autonomy package',
    license='TODO',
    tests_require=['pytest'],
    entry_points={
        'console_scripts': [
            'lane_detection = car_autonomy.lane_detection:main',
            'lane_follower = car_autonomy.lane_follower:main',
        ],
    },
)

--- File: ./src/car_autonomy/setup.cfg ---
[develop]
script_dir=$base/lib/car_autonomy
[install]
install_scripts=$base/lib/car_autonomy

--- File: ./src/car_autonomy/test/test_copyright.py ---
# Copyright 2015 Open Source Robotics Foundation, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from ament_copyright.main import main
import pytest


# Remove the `skip` decorator once the source file(s) have a copyright header
@pytest.mark.skip(reason='No copyright header has been placed in the generated source file.')
@pytest.mark.copyright
@pytest.mark.linter
def test_copyright():
    rc = main(argv=['.', 'test'])
    assert rc == 0, 'Found errors'

--- File: ./src/car_autonomy/test/test_pep257.py ---
# Copyright 2015 Open Source Robotics Foundation, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from ament_pep257.main import main
import pytest


@pytest.mark.linter
@pytest.mark.pep257
def test_pep257():
    rc = main(argv=['.', 'test'])
    assert rc == 0, 'Found code style errors / warnings'

--- File: ./src/car_autonomy/test/test_flake8.py ---
# Copyright 2017 Open Source Robotics Foundation, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from ament_flake8.main import main_with_errors
import pytest


@pytest.mark.flake8
@pytest.mark.linter
def test_flake8():
    rc, errors = main_with_errors(argv=[])
    assert rc == 0, \
        'Found %d code style errors / warnings:\n' % len(errors) + \
        '\n'.join(errors)

--- File: ./src/car_bringup/launch/sensors.launch.py ---
#!/usr/bin/env python3

from launch import LaunchDescription
from launch_ros.actions import Node
from launch.actions import DeclareLaunchArgument
from launch.substitutions import LaunchConfiguration

def generate_launch_description():
    
    serial_port_arg = DeclareLaunchArgument(
        'serial_port',
        default_value='/dev/ttyTHS1',
        description='Serial port for STM32'
    )
    
    # STM32 Driver Node (sensors only mode)
    stm32_driver = Node(
        package='car_hardware',
        executable='stm32_driver',
        name='stm32_driver_node',
        output='screen',
        parameters=[{
            'serial_port': LaunchConfiguration('serial_port'),
            'baud_rate': 115200
        }]
    )
    
    return LaunchDescription([
        serial_port_arg,
        stm32_driver,
    ])

--- File: ./src/car_bringup/launch/teleop.launch.py ---
#!/usr/bin/env python3

from launch import LaunchDescription
from launch_ros.actions import Node
from launch.actions import DeclareLaunchArgument
from launch.substitutions import LaunchConfiguration

def generate_launch_description():
    
    # Declare arguments
    serial_port_arg = DeclareLaunchArgument(
        'serial_port',
        default_value='/dev/ttyTHS1',
        description='Serial port for STM32'
    )
    
    # STM32 Driver Node
    stm32_driver = Node(
        package='car_hardware',
        executable='stm32_driver',
        name='stm32_driver_node',
        output='screen',
        parameters=[{
            'serial_port': LaunchConfiguration('serial_port'),
            'baud_rate': 115200,
            'wheel_base': 0.25,
            'max_speed': 1.0,
            'max_steering_angle': 40.0
        }]
    )
    
    # Teleop Keyboard Node
    teleop_keyboard = Node(
        package='car_hardware',
        executable='teleop_keyboard',
        name='teleop_keyboard_node',
        output='screen',
        parameters=[{
            'speed_step': 0.1,
            'turn_step': 0.3,
            'max_speed': 1.0,
            'max_turn': 1.0
        }],
        prefix='xterm -e'  # Run in separate terminal
    )
    
    return LaunchDescription([
        serial_port_arg,
        stm32_driver,
        # teleop_keyboard,  # Uncomment to auto-launch teleop
    ])

--- File: ./src/car_bringup/package.xml ---
<?xml version="1.0"?>
<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
<package format="3">
  <name>car_bringup</name>
  <version>0.0.0</version>
  <description>TODO: Package description</description>
  <maintainer email="root@todo.todo">root</maintainer>
  <license>TODO: License declaration</license>

  <buildtool_depend>ament_cmake</buildtool_depend>

  <test_depend>ament_lint_auto</test_depend>
  <test_depend>ament_lint_common</test_depend>

  <export>
    <build_type>ament_cmake</build_type>
  </export>
</package>

--- File: ./src/car_bringup/CMakeLists.txt ---
cmake_minimum_required(VERSION 3.8)
project(car_bringup)

if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
  add_compile_options(-Wall -Wextra -Wpedantic)
endif()

# find dependencies
find_package(ament_cmake REQUIRED)

# Install launch files
install(DIRECTORY
  launch
  config
  DESTINATION share/${PROJECT_NAME}/
)

if(BUILD_TESTING)
  find_package(ament_lint_auto REQUIRED)
  ament_lint_auto_find_test_dependencies()
endif()

ament_package()

--- File: ./src/car_hardware/resource/car_hardware ---

--- File: ./src/car_hardware/package.xml ---
<?xml version="1.0"?>
<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
<package format="3">
  <name>car_hardware</name>
  <version>0.0.0</version>
  <description>TODO: Package description</description>
  <maintainer email="root@todo.todo">root</maintainer>
  <license>TODO: License declaration</license>

  <depend>rclpy</depend>
  <depend>geometry_msgs</depend>
  <depend>sensor_msgs</depend>
  <depend>std_msgs</depend>
  <depend>nav_msgs</depend>

  <test_depend>ament_copyright</test_depend>
  <test_depend>ament_flake8</test_depend>
  <test_depend>ament_pep257</test_depend>
  <test_depend>python3-pytest</test_depend>

  <export>
    <build_type>ament_python</build_type>
  </export>
</package>

--- File: ./src/car_hardware/setup.py ---
from setuptools import setup
import os
from glob import glob

package_name = 'car_hardware'

setup(
    name=package_name,
    version='0.0.1',
    packages=[package_name],
    data_files=[
        ('share/ament_index/resource_index/packages',
            ['resource/' + package_name]),
        ('share/' + package_name, ['package.xml']),
    ],
    install_requires=['setuptools'],
    zip_safe=True,
    maintainer='your_name',
    maintainer_email='your_email@example.com',
    description='Hardware interface for RC car',
    license='MIT',
    tests_require=['pytest'],
    entry_points={
        'console_scripts': [
            'stm32_driver = car_hardware.stm32_driver_node:main',
            'teleop_keyboard = car_hardware.teleop_keyboard_node:main',
            'game_control_cli = car_hardware.game_control_cli:main',
            'servo_calibration_node = car_hardware.servo_calibration_node:main',

        ],
    },
)

--- File: ./src/car_hardware/setup.cfg ---
[develop]
script_dir=$base/lib/car_hardware
[install]
install_scripts=$base/lib/car_hardware

--- File: ./src/car_hardware/car_hardware/stm32_driver_node.py ---
#!/usr/bin/env python3
"""
STM32 Driver Node (Optimized)
Improvements: 
1. Dynamic dt calculation for accurate Yaw integration.
2. Allows steering wheels to turn even when stopped.
3. Thread-safe serial writes.
4. Robust shutdown procedure.
"""

import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist
from sensor_msgs.msg import Imu
from std_msgs.msg import Int32
import serial
import threading
import math
import time

class STM32DriverNode(Node):
    def __init__(self):
        super().__init__('stm32_driver_node')

        # --- Parameters ---
        self.declare_parameter('serial_port', '/dev/ttyTHS1')
        self.declare_parameter('baud_rate', 115200)
        self.declare_parameter('wheel_base', 0.135)
        self.declare_parameter('max_speed_m_s', 1.0) # Renamed for clarity
        self.declare_parameter('max_steering_angle_deg', 25.0)

        self.port = self.get_parameter('serial_port').value
        self.baud = self.get_parameter('baud_rate').value
        self.wheel_base = self.get_parameter('wheel_base').value
        self.max_speed = self.get_parameter('max_speed_m_s').value
        self.max_steer = self.get_parameter('max_steering_angle_deg').value

        # --- Serial Connection ---
        self.serial = None
        self.serial_lock = threading.Lock() # Prevent read/write collisions
        self._open_serial()

        # --- ROS2 Interfaces ---
        self.encoder_pub = self.create_publisher(Int32, 'encoder_count', 10)
        self.imu_pub = self.create_publisher(Imu, 'imu/data_raw', 10)
        
        self.cmd_vel_sub = self.create_subscription(
            Twist, 'cmd_vel', self.cmd_vel_callback, 10
        )

        # --- State Variables ---
        self.last_imu_time = self.get_clock().now()
        self.integrated_yaw = 0.0
        
        # --- Threading ---
        self.running = True
        self.read_thread = threading.Thread(target=self.serial_read_loop, daemon=True)
        self.read_thread.start()

        self.get_logger().info("STM32 Driver Node initialized.")

    def _open_serial(self):
        try:
            if self.serial and self.serial.is_open:
                self.serial.close()
            self.serial = serial.Serial(self.port, self.baud, timeout=0.1)
            self.get_logger().info(f"Connected to STM32 on {self.port}")
        except Exception as e:
            self.get_logger().error(f"Failed to open serial port: {e}")
            self.serial = None

    # ---------------------------
    #  CMD_VEL CALLBACK (Control)
    # ---------------------------
    def cmd_vel_callback(self, msg):
        linear = msg.linear.x
        angular = msg.angular.z

        # --- CALIBRATION VALUES ---
        # 90 is usually center. Adjust this if your car goes straight at 95 or 85.
        SERVO_CENTER = 90  
        SERVO_MIN    = 20
        SERVO_MAX    = 137
        
        # Max Steering Angle (in servo steps)
        # e.g. 30 means it can go from 60 (90-30) to 120 (90+30)
        STEERING_RANGE = 40 
        # --------------------------

        # 1. DIRECT MAPPING (Simplified)
        # We assume angular.z is normalized roughly between -1.0 and 1.0 by the lane follower.
        # -1.0 = Max Right, 0.0 = Straight, 1.0 = Max Left
        
        # Invert logic: If positive angular (Left) needs servo to go UP, use +
        # If positive angular (Left) needs servo to go DOWN, use -
        # Based on your previous code (90 - shift), it seems NEGATIVE is correct.
        servo_shift = int(angular * STEERING_RANGE)
        servo_cmd = SERVO_CENTER - servo_shift

        # 2. Safety Clamp
        servo_cmd = max(SERVO_MIN, min(SERVO_MAX, servo_cmd))

        # 3. Calculate Motor Speed
        # Map 0.0 - 1.0 m/s to 0 - 100 PWM
        speed_cmd = int((linear / self.max_speed) * 100)
        speed_cmd = max(-100, min(100, speed_cmd))

        self.send_packet(speed_cmd, servo_cmd)

    def send_packet(self, speed, angle):
        if not self.serial:
            return
        
        packet = f"#CMD,{speed},{angle}*\n" # Added \n for robustness
        try:
            with self.serial_lock:
                self.serial.write(packet.encode())
        except Exception as e:
            self.get_logger().warn(f"Serial write failed: {e}")
            self._open_serial()

    # ---------------------------
    #  SERIAL READ LOOP
    # ---------------------------
    def serial_read_loop(self):
        while self.running and rclpy.ok():
            if not self.serial:
                time.sleep(1)
                self._open_serial()
                continue

            try:
                # readline blocks for timeout (0.1s)
                line = self.serial.readline().decode('utf-8', errors='ignore').strip()
                
                if not line:
                    continue # Timeout or empty

                # Validate Packet Format
                if line.startswith('$') and line.endswith('*'):
                    self.parse_sensor_data(line)
            
            except serial.SerialException:
                self.get_logger().error("Serial connection lost.")
                self.serial.close()
                self.serial = None
            except Exception as e:
                self.get_logger().warn(f"Read error: {e}")

    # ---------------------------
    #  PARSING & PUBLISHING
    # ---------------------------
    def parse_sensor_data(self, line):
        # Format: $ENC,12345;IMU,ax,ay,az,gx,gy,gz,roll,pitch*
        try:
            content = line[1:-1] # Strip $ and *
            parts = content.split(';')
            
            for part in parts:
                if part.startswith("ENC"):
                    self.handle_encoder(part)
                elif part.startswith("IMU"):
                    self.handle_imu(part)
        except ValueError:
            pass # Malformed numbers

    def handle_encoder(self, part):
        # part = "ENC,12345"
        try:
            val = int(part.split(',')[1])
            msg = Int32()
            msg.data = val
            self.encoder_pub.publish(msg)
        except IndexError:
            pass

    def handle_imu(self, part):
        # part = "IMU,ax,ay,az,gx,gy,gz,roll,pitch" (integers scaled)
        # SCALING MUST MATCH STM32 CODE:
        # Accel / 1000.0, Gyro / 100.0, Euler / 100.0
        vals = part.split(',')[1:]
        if len(vals) < 8: return

        ax = float(vals[0]) / 1000.0
        ay = float(vals[1]) / 1000.0
        az = float(vals[2]) / 1000.0
        gx = float(vals[3]) / 100.0
        gy = float(vals[4]) / 100.0
        gz = float(vals[5]) / 100.0
        # roll/pitch ignored for orientation calculation 
        # because we calculate quaternion from gyro integration + accel usually, 
        # but here we just use what we have.

        # --- Dynamic Time Integration ---
        current_time = self.get_clock().now()
        dt = (current_time - self.last_imu_time).nanoseconds / 1e9
        self.last_imu_time = current_time

        # Avoid integration spikes if connection lagged
        if dt > 1.0: dt = 0.0 

        # Integrate Yaw (Gyro Z)
        self.integrated_yaw += math.radians(gz) * dt

        self.publish_imu_msg(ax, ay, az, gx, gy, gz)

    def publish_imu_msg(self, ax, ay, az, gx, gy, gz):
        msg = Imu()
        msg.header.stamp = self.get_clock().now().to_msg()
        msg.header.frame_id = "imu_link"

        # Linear Accel
        msg.linear_acceleration.x = ax * 9.81
        msg.linear_acceleration.y = ay * 9.81
        msg.linear_acceleration.z = az * 9.81

        # Angular Velocity
        msg.angular_velocity.x = math.radians(gx)
        msg.angular_velocity.y = math.radians(gy)
        msg.angular_velocity.z = math.radians(gz)

        # Orientation (Quaternion from Yaw only for planar robot)
        # Assuming the robot stays mostly flat, we simplify to Yaw rotation
        cy = math.cos(self.integrated_yaw * 0.5)
        sy = math.sin(self.integrated_yaw * 0.5)
        
        # Simple Yaw-only Quaternion (w, x, y, z)
        msg.orientation.w = cy
        msg.orientation.x = 0.0
        msg.orientation.y = 0.0
        msg.orientation.z = sy

        self.imu_pub.publish(msg)

    def destroy_node(self):
        self.running = False
        # Stop the robot on shutdown
        self.send_packet(0, 90) 
        if self.serial:
            self.serial.close()
        super().destroy_node()

def main(args=None):
    rclpy.init(args=args)
    node = STM32DriverNode()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == "__main__":
    main()

--- File: ./src/car_hardware/car_hardware/__init__.py ---

--- File: ./src/car_hardware/car_hardware/servo_calibration_node.py ---
#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
import serial
import sys
import termios
import tty
import time

class ServoCalibrationNode(Node):
    def __init__(self):
        super().__init__('servo_calibration_node')

        # --- Parameters ---
        self.declare_parameter('serial_port', '/dev/ttyTHS1')
        self.declare_parameter('baud_rate', 115200)

        self.port = self.get_parameter('serial_port').value
        self.baud = self.get_parameter('baud_rate').value

        # --- Serial Connection ---
        # We open this DIRECTLY (bypassing the main driver) to get raw access
        try:
            self.serial = serial.Serial(self.port, self.baud, timeout=0.1)
            self.get_logger().info(f"Connected to STM32 on {self.port}")
        except Exception as e:
            self.get_logger().error(f"Failed to open serial port: {e}")
            sys.exit(1)

        self.servo_val = 90  # Start at center
        self.print_instructions()

    def print_instructions(self):
        print("\n========================================")
        print("   STM32 SERVO CALIBRATION NODE")
        print("========================================")
        print("Controls:")
        print("  [a]   Left  (-1)")
        print("  [d]   Right (+1)")
        print("  [A]   Left  (-5)")
        print("  [D]   Right (+5)")
        print("  [s]   Reset Center (90)")
        print("  [q]   Quit & Calculate Results")
        print("----------------------------------------")

    def get_key(self):
        """Reads a single keypress from stdin"""
        fd = sys.stdin.fileno()
        old_settings = termios.tcgetattr(fd)
        try:
            tty.setraw(sys.stdin.fileno())
            ch = sys.stdin.read(1)
        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
        return ch

    def send_cmd(self, angle):
        """Sends raw #CMD packet. Speed is always 0 during calibration."""
        # PACKET FORMAT: #CMD,speed,angle* (No newline \n)
        packet = f"#CMD,0,{angle}*"
        try:
            self.serial.write(packet.encode())
        except Exception as e:
            self.get_logger().warn(f"Serial write failed: {e}")

    def run(self):
        # Interactive Loop
        try:
            # Initial center command
            self.send_cmd(self.servo_val)
            print(f"\rCurrent Servo PWM: {self.servo_val}", end="")

            while rclpy.ok():
                key = self.get_key()
                
                if key == 'a':
                    self.servo_val -= 1
                elif key == 'd':
                    self.servo_val += 1
                elif key == 'A':
                    self.servo_val -= 5
                elif key == 'D':
                    self.servo_val += 5
                elif key == 's':
                    self.servo_val = 90
                elif key == 'q':
                    self.calculate_and_exit()
                    break
                elif key == '\x03': # Ctrl+C
                    break

                # Safety Clamp
                self.servo_val = max(0, min(180, self.servo_val))
                
                self.send_cmd(self.servo_val)
                print(f"\rCurrent Servo PWM: {self.servo_val}   ", end="")
                
        except Exception as e:
            print(e)
        finally:
            self.send_cmd(90) # Reset to safe center on exit
            if self.serial:
                self.serial.close()

    def calculate_and_exit(self):
        # Restore terminal settings for input()
        # (termios/tty messed them up for get_key)
        # We simply use print/input normally here as the loop is done.
        
        print("\n\n========================================")
        print("       CALIBRATION DATA ENTRY")
        print("========================================")
        
        try:
            # 1. CENTER
            print(f"1. Center PWM (Last position: {self.servo_val})")
            c_input = input(f"   Enter Center PWM [default {self.servo_val}]: ")
            val_center = int(c_input) if c_input else self.servo_val

            # 2. LEFT LIMIT
            print("\n2. Left Limit")
            val_left = int(input("   Enter PWM used for MAX LEFT: "))
            angle_left = float(input("   Enter Measured INNER Wheel Angle (deg): "))

            # 3. RIGHT LIMIT
            print("\n3. Right Limit")
            val_right = int(input("   Enter PWM used for MAX RIGHT: "))
            angle_right = float(input("   Enter Measured INNER Wheel Angle (deg): "))

            # Calculations
            # Ratio = Delta PWM / Angle
            ratio_l = abs(val_left - val_center) / angle_left
            ratio_r = abs(val_right - val_center) / angle_right
            avg_ratio = (ratio_l + ratio_r) / 2.0
            
            offset = val_center - 90

            self.get_logger().info("CALIBRATION COMPLETE")
            print("\n****************************************")
            print("   COPY THESE VALUES TO PYTHON DRIVER")
            print("****************************************")
            print(f"STEERING_RATIO = {avg_ratio:.2f}")
            print(f"SERVO_OFFSET   = {offset}")
            print(f"PWM_RANGE      = ({min(val_left, val_right)}, {max(val_left, val_right)})")
            print("****************************************")

        except ValueError:
            self.get_logger().error("Invalid input. Please enter numbers only.")

def main(args=None):
    rclpy.init(args=args)
    node = ServoCalibrationNode()
    
    # We don't use rclpy.spin() because we have a blocking input loop
    # The node handles its own loop in node.run()
    node.run()

    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
--- File: ./src/car_hardware/car_hardware/game_control_cli.py ---
#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist
import sys, select, termios, tty
import time
import numpy as np

# --- CONFIGURATION ---
REAL_MAX_SPEED_M_S = 1.0     # 1.0 m/s
REAL_WHEELBASE_M = 0.25      # 0.25m
STEER_LIMIT_DEG = 40.0       # Max steering angle
CMD_FREQ = 20.0              # Hz
LOOP_TIMEOUT = 1.0 / CMD_FREQ # New: Timeout used to control loop rate

# Physics / Feel
ACCEL_STEP = 0.05            # Speed increase per loop while holding W
BRAKE_STEP = 0.10            # Speed decrease per loop while holding S
STEER_STEP = 4.0             # Degrees change per loop
FRICTION   = 0.02            # Deceleration when key released
STEER_CENTERING = 2.0        # Auto-center steering when key released

# Timeout to detect "key release"
KEY_TIMEOUT = 0.15          

class KeyboardController(Node):
    def __init__(self):
        super().__init__('game_control_cli')
        self.publisher_ = self.create_publisher(Twist, 'cmd_vel', 10)
        
        # Save and set terminal settings once
        self.settings = termios.tcgetattr(sys.stdin)
        tty.setraw(sys.stdin.fileno()) # Set raw mode once for the duration of the node
        
        # State
        self.speed = 0.0     # -1.0 to 1.0
        self.steer = 0.0     # Degrees
        self.last_key_time = time.time()
        self.key_pressed = None

        print(f"""
        ---------------------------
          WASD GAME CONTROLLER
        ---------------------------
          W : Accelerate
          S : Brake / Reverse
          A : Steer Left
          D : Steer Right
        SPACE : E-Stop
        ---------------------------
        Running... Press Ctrl+C to quit.
        """)

    def get_key(self, timeout=LOOP_TIMEOUT):
        """Non-blocking keyboard read, assumes terminal is already in raw mode."""
        # Check for key press using select with a timeout
        rlist, _, _ = select.select([sys.stdin], [], [], timeout) 
        if rlist:
            # Read a character
            key = sys.stdin.read(1)
        else:
            key = ''
        return key

    def control_logic(self, key):
        """
        Calculates new speed/steer states based on key press 
        and publishes the Twist message.
        """
        
        # Determine user input
        if key in ['w', 's', 'a', 'd', ' ']:
            self.last_key_time = time.time()
            self.key_pressed = key
        elif key == '\x03': # Ctrl+C
            raise KeyboardInterrupt # Use an exception to cleanly exit the run loop
            
        # Check for key release (timeout)
        if time.time() - self.last_key_time > KEY_TIMEOUT:
            self.key_pressed = None

        # --- PHYSICS LOGIC ---
        
        # Throttle (W/S)
        if self.key_pressed == 'w':
            self.speed += ACCEL_STEP
        elif self.key_pressed == 's':
            self.speed -= BRAKE_STEP
        elif self.key_pressed == ' ':
            self.speed = 0.0
            self.steer = 0.0
        else:
            # Friction (Coast to stop)
            if self.speed > 0: self.speed -= FRICTION
            if self.speed < 0: self.speed += FRICTION
            if abs(self.speed) < FRICTION: self.speed = 0.0

        # Steering (A/D)
        if self.key_pressed == 'a':
            self.steer += STEER_STEP
        elif self.key_pressed == 'd':
            self.steer -= STEER_STEP
        else:
            # Auto-Center
            if self.steer > 0: self.steer -= STEER_CENTERING
            if self.steer < 0: self.steer += STEER_CENTERING
            if abs(self.steer) < STEER_CENTERING: self.steer = 0.0

        # Clamping
        self.speed = np.clip(self.speed, -1.0, 1.0)
        self.steer = np.clip(self.steer, -STEER_LIMIT_DEG, STEER_LIMIT_DEG)

        self.publish_cmd()

    def publish_cmd(self):
        msg = Twist()
        
        # Map percentage to real speed
        msg.linear.x = float(self.speed * REAL_MAX_SPEED_M_S)
        
        # Calculate Angular Velocity for Ackermann
        # w = (v * tan(theta)) / L
        steer_rad = np.radians(self.steer)
        
        # Small trick: Allow steering even if stopped (send tiny speed)
        # to prevent division by zero or logic errors in driver
        calc_speed = msg.linear.x if abs(msg.linear.x) > 0.01 else 0.01
        
        msg.angular.z = float((calc_speed * np.tan(steer_rad)) / REAL_WHEELBASE_M)

        self.publisher_.publish(msg)
        
        # Print status line (overwrite same line)
        sys.stdout.write(f"\rSpeed: {self.speed*100:3.0f}% | Steer: {self.steer:3.0f} deg   ")
        sys.stdout.flush()

    def run(self):
        """Main execution loop that replaces rclpy.spin() for teleop."""
        while rclpy.ok():
            try:
                # 1. Get key input (blocks for LOOP_TIMEOUT)
                key = self.get_key(timeout=LOOP_TIMEOUT)
                
                # 2. Process logic and publish
                self.control_logic(key)
                
                # 3. Allow ROS to process any pending callbacks (like timer/subscriptions if added later)
                rclpy.spin_once(self, timeout_sec=0) 
                
            except KeyboardInterrupt:
                break
            except Exception as e:
                self.get_logger().error(f'Runtime Error: {e}')
                break
        
        # Cleanup when the loop exits
        self.shutdown()


    def shutdown(self):
        print("\nStopping...")
        # Send zero velocity command
        msg = Twist()
        self.publisher_.publish(msg)
        
        # Restore terminal settings
        termios.tcsetattr(sys.stdin, termios.TCSADRAIN, self.settings)
        
        self.destroy_node()
        rclpy.shutdown()
        sys.exit(0) # Exit cleanly

def main():
    rclpy.init()
    node = KeyboardController()
    node.run() # Start the main control loop

if __name__ == '__main__':
    main()
--- File: ./src/car_hardware/car_hardware/teleop_keyboard_node.py ---
#!/usr/bin/env python3
"""
Keyboard Teleop Node for RC Car
"""

import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist
import sys
import select
import termios
import tty

INSTRUCTIONS = """
RC Car Keyboard Control
-----------------------
   w
a  s  d

w/s : increase/decrease speed
a/d : turn left/right
space : stop
q : quit

CTRL-C to quit
"""

class TeleopKeyboardNode(Node):
    def __init__(self):
        super().__init__('teleop_keyboard_node')
        
        # Parameters
        self.declare_parameter('speed_step', 0.1)
        self.declare_parameter('turn_step', 0.3)
        self.declare_parameter('max_speed', 1.0)
        self.declare_parameter('max_turn', 1.0)
        
        self.speed_step = self.get_parameter('speed_step').value
        self.turn_step = self.get_parameter('turn_step').value
        self.max_speed = self.get_parameter('max_speed').value
        self.max_turn = self.get_parameter('max_turn').value
        
        # Publisher
        self.cmd_vel_pub = self.create_publisher(Twist, 'cmd_vel', 10)
        
        # Current velocities
        self.linear_vel = 0.0
        self.angular_vel = 0.0
        
        # Terminal settings
        self.settings = termios.tcgetattr(sys.stdin)
        
        self.get_logger().info('Teleop Keyboard Node initialized')
        print(INSTRUCTIONS)
    
    def get_key(self, timeout=0.1):
        """Get keyboard input"""
        tty.setraw(sys.stdin.fileno())
        rlist, _, _ = select.select([sys.stdin], [], [], timeout)
        if rlist:
            key = sys.stdin.read(1)
        else:
            key = ''
        termios.tcsetattr(sys.stdin, termios.TCSADRAIN, self.settings)
        return key
    
    def publish_twist(self):
        """Publish velocity"""
        twist = Twist()
        twist.linear.x = self.linear_vel
        twist.angular.z = self.angular_vel
        self.cmd_vel_pub.publish(twist)
        print(f'\rSpeed: {self.linear_vel:.2f} m/s | Turn: {self.angular_vel:.2f} rad/s', end='')
    
    def run(self):
        """Main loop"""
        try:
            while rclpy.ok():
                key = self.get_key()
                
                if key == 'w':
                    self.linear_vel = min(self.linear_vel + self.speed_step, self.max_speed)
                elif key == 's':
                    self.linear_vel = max(self.linear_vel - self.speed_step, -self.max_speed)
                elif key == 'a':
                    self.angular_vel = min(self.angular_vel + self.turn_step, self.max_turn)
                elif key == 'd':
                    self.angular_vel = max(self.angular_vel - self.turn_step, -self.max_turn)
                elif key == ' ':
                    self.linear_vel = 0.0
                    self.angular_vel = 0.0
                elif key == 'q':
                    break
                
                self.publish_twist()
                
        except Exception as e:
            self.get_logger().error(f'Error: {e}')
        finally:
            self.linear_vel = 0.0
            self.angular_vel = 0.0
            self.publish_twist()
            termios.tcsetattr(sys.stdin, termios.TCSADRAIN, self.settings)


def main(args=None):
    rclpy.init(args=args)
    node = TeleopKeyboardNode()
    
    try:
        node.run()
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()

--- File: ./src/car_hardware/test/test_copyright.py ---
# Copyright 2015 Open Source Robotics Foundation, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from ament_copyright.main import main
import pytest


# Remove the `skip` decorator once the source file(s) have a copyright header
@pytest.mark.skip(reason='No copyright header has been placed in the generated source file.')
@pytest.mark.copyright
@pytest.mark.linter
def test_copyright():
    rc = main(argv=['.', 'test'])
    assert rc == 0, 'Found errors'

--- File: ./src/car_hardware/test/test_pep257.py ---
# Copyright 2015 Open Source Robotics Foundation, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from ament_pep257.main import main
import pytest


@pytest.mark.linter
@pytest.mark.pep257
def test_pep257():
    rc = main(argv=['.', 'test'])
    assert rc == 0, 'Found code style errors / warnings'

--- File: ./src/car_hardware/test/test_flake8.py ---
# Copyright 2017 Open Source Robotics Foundation, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from ament_flake8.main import main_with_errors
import pytest


@pytest.mark.flake8
@pytest.mark.linter
def test_flake8():
    rc, errors = main_with_errors(argv=[])
    assert rc == 0, \
        'Found %d code style errors / warnings:\n' % len(errors) + \
        '\n'.join(errors)

--- File: ./codebase.txt ---

--- File: ./create_codebase.sh ---
#!/bin/bash

# A script to convert a codebase into a single text file with hierarchy,
# ignoring specified files and directories.

# Set the output file name
OUTPUT_FILE="codebase.txt"

# Set the root directory of your codebase
# By default, it uses the current directory where the script is run
CODE_ROOT_DIR="."

# Define the files and directories to ignore 🚫
# IMPORTANT: Directories MUST end with a trailing slash to be correctly ignored.
# This tells the script's logic to use the efficient -prune option.
EXCLUDE_LIST=(
    ".git/"
    "node_modules/"
    "__pycache__/"
    "dist/"
    "*.log"
    "*.pyc"
    "*.avi"
    "build/"
    "install/"
    "log"
    "README.md"
)

# Clear the output file if it exists
> "$OUTPUT_FILE"

echo "Generating codebase hierarchy..."
# Convert the bash array to a format 'tree' understands: 'pattern1|pattern2|...'
EXCLUDE_STRING=$(printf "%s|" "${EXCLUDE_LIST[@]}")
EXCLUDE_STRING=${EXCLUDE_STRING%?} # Remove the last pipe character

# Use 'tree' with the -I option to exclude directories and files
tree -a -I "$EXCLUDE_STRING" "$CODE_ROOT_DIR" >> "$OUTPUT_FILE"

echo "" >> "$OUTPUT_FILE"
echo "==========================================" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

echo "Concatenating file contents..."

# Build the find command dynamically to apply exclusions correctly
FIND_CMD="find \"$CODE_ROOT_DIR\""

# Add the exclusion logic for each item
for item in "${EXCLUDE_LIST[@]}"; do
    if [[ "$item" == */ ]]; then
        # This is a directory, use -prune to skip it and its contents
        FIND_CMD+=" -path \"$CODE_ROOT_DIR/${item%?}\" -prune -o"
    else
        # This is a file, use ! -name to exclude it
        FIND_CMD+=" -name \"$item\" -prune -o"
    fi
done

# Add the final -type f to select only files that haven't been pruned
FIND_CMD+=" -type f -print0"

# Use eval to execute the dynamically built find command, and pipe to while loop
eval "$FIND_CMD" | while IFS= read -r -d $'\0' file; do
    echo "--- File: $file ---" >> "$OUTPUT_FILE"
    cat "$file" >> "$OUTPUT_FILE"
    echo "" >> "$OUTPUT_FILE" # Add a newline for separation
done

echo "Done! Codebase has been exported to $OUTPUT_FILE"

--- File: ./.gitignore ---
build/
install/
log/
.vscode/

